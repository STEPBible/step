/******************************************************************************/
/* Displays chronology details.

   The details are shown on a vertical line, spaced in a 'reasonably' optimal
   manner (although this does mean that the user may have to scroll to see all
   of them).

   The caller should supply a div when calling init, and the chronology
   functionality is placed within that div.

   The data is generated by a Kotlin program 'FormatChronologyData', based upon
   data which is extracted manually from https://docs.google.com/spreadsheets/d/15WmvZ4C-6G62Cd9JuIvtcqGfJ_vEhi6YohSht4fmZZg/edit?gid=0#gid=0.

   See JChronologyData for more details.



   External access via URLs
   ========================

   showWelcome: If this appears as a URL parameter, it causes the welcome
     screen to be shown on entry.  In fact we may or may not allow for a
     welcome screen -- the jury is still out.  If used at all, I anticipate
     it will only be when coming from the Resources menu, and I will _probably_
     arrange for it to be shown only once.

   year=1000BC: This may be any date at all.  If the date corresponds to a
     particular event (or to the start of a duration, which is treated as
     though it were an event), that event is selected and made visible.
     If it does not have an associated event, things are positioned
     somewhere near the element.  The date should include one of AD, BC or
     AM (but no space).  I don't mind whether the letters are placed at the
     beginning or the end.  Dates are based upon the 'OtherDate' column of
     the chronology data.

   No year parameter: Acts as though year=3BC had been specified.  This
     corresponds to the nearest event to what would be AD 0 if such a
     date existed.



  External access via interframe communications
  =============================================

  At the time of writing, this relates purely to calls from the search frame,
  which is handled by a message containing a 'key' field.
*/
/******************************************************************************/

'use strict';

import { JFrameworkStepDataAccessors }                  from '/js/J_AppsJs/J_Framework/j_framework.stepDataAccessors.js';
import { ClassJFrameworkDraggable }                     from '/js/J_AppsJs/J_Framework/j_framework.draggable.js';
import { ClassJFrameworkModalDialog }                   from '/js/J_AppsJs/J_Framework/j_framework.modalDialog.js';
import { ClassJFrameworkMultiframeCommunicationsSlave } from '/js/J_AppsJs/J_Framework/j_framework.multiframeCommunicationsSlave.js';
import { JChronologyData }                              from '/js/J_AppsJs/J_Chronology/j_chronologySharedCode.js';
import { JFrameworkSharedConstants }                    from '/js/J_AppsJs/J_Framework/j_framework.sharedConstants.js';
import { JFrameworkUserSettings }                       from '/js/J_AppsJs/J_Framework/j_framework.userSettings.js';
import { JFrameworkUtils }                              from '/js/J_AppsJs/J_Framework/j_framework.utils.js';
import { JFrameworkChapterSummaries }                   from '/js/J_AppsJs/J_Framework/j_framework.chapterSummaries.js';

export const ModalDialogHandler = new ClassJFrameworkModalDialog();
window.ModalDialogHandler = ModalDialogHandler;





/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                                   Main                                   **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
class _ClassJChronology extends ClassJFrameworkMultiframeCommunicationsSlave
{
    /**************************************************************************/
    /* We need to obtain the data and then run the bulk of the processing.  To
       that end, I have to pass something which does the bulk processing as an
       argument to the read method. */

    onload (container)
    {
	this._container = container;

	JFrameworkSharedConstants.setHrefs();
	
	JChronologyData.loadData(this._onload.bind(this)); // Get the data.
	
	ModalDialogHandler.addModalCloseButtonHandlers(); // Add close handlers to everything which has a close button.
	
	ClassJFrameworkDraggable.initialise(); // Make any appropriate pop-ups draggable.

	document.querySelector('.alternativeChronologySelectUssher').addEventListener('click', () => {
	    JEventHandlers.alternativeChronologiesSelectorOk('Ussher');
	});

	document.querySelector('.alternativeChronologySelectOther').addEventListener('click', () => {
	    JEventHandlers.alternativeChronologiesSelectorOk('Other');
	});

	document.querySelector('.alternativeChronologyCancel').addEventListener('click', () => {
	    JEventHandlers.alternativeChronologiesSelectorCancel();
	});
    }


    /*************************************************************************/
    /* Receives inter-iframe messages and processes them. */

    receiveMessage (data, callingFrameId)
    {
	_JChronologyPresentationHandler.selectEvent(JChronologyData.getEventDateAndMarkerDivGivenKey(data.key));
    }

    
    /**************************************************************************/
    resize ()
    {
	JTimelineRenderer.adjustPositionOfLine();
	JChronology._checkDurationOverlaps();
	this._respondToFrameWidthChanges();
    }

    
    /**************************************************************************/
    /* The URL for the present page may be 'revised' (including set up for the
       first time) either because of a direct intervention from the 3-panel
       page, or because the people index pane has been used to select a new
       person.

       The former occurs where the 3-panel has been invoked from the sidebar
       as a result of someone looking up Strong's information while reading
       scripture.  The latter (ie when invoked from the people index) occurs
       when already in 3-pane mode, and selecting a new person.

       There is also the possibility that the present code may be called with
       no selection at all, in which case I have been asked to default to
       Aaron. */
  
    _makeInitialSelection ()
    {
	/**********************************************************************/
	const urlParms = new URLSearchParams(new URL(window.location.href).search);
	var year = urlParms.get('year') ?? '6BC'; // Date Jesus born.
	var showWelcome = urlParms.has('showWelcome');
	var type = urlParms.get('type') ?? 'event';



	/**********************************************************************/
	const selection = JChronologyData.findBracketingEntries(year, type);
	if (null === selection.match) // A date not actually marked on the timeline.
	{
	    const unifiedYear = JFrameworkUtils.convertToUnifiedYear(year);
	    const pos = unifiedYear < JChronologyData.getLastUyearInAm() ? JTimelineRenderer.rawPositionForAmDate(unifiedYear) : JTimelineRenderer.rawPositionForNonAmDate(unifiedYear);
	    _JChronologyPresentationHandler.selectNonEvent(pos);
	}	    
	else
	{
	    const key = JChronologyData.getKey(selection.match);
	    const matchingDiv = JChronologyData.getEventDateAndMarkerDivGivenKey(key);
	    _JChronologyPresentationHandler.selectEvent(matchingDiv);
	}



	/**********************************************************************/
	if (showWelcome)
	{
	    if (null == localStorage.getItem('JChronologyHaveShownWelcome'))
	    {
		localStorage.setItem('JChronologyHaveShownWelcome', 'Yes');
		JEventsHandler.showWelcome();
	    }
	}
    }


    /**************************************************************************/
    /* Carries out initialisation once all of the data has been loaded. */
    
    _onload ()
    {
	/**********************************************************************/
	/* Determine the width of the frame, so that things are initialised to
	   have the correct visibility. */
	
	this._updateFrameWidth();


	
	/**********************************************************************/
	/* Some of the fields are supplied in at most partly finished form.
	   These need to be updated to take into account how we actually want
	   to process them. */
	
	JChronologyData.reformatData(JChronologyData.withLinks);


	
	/**********************************************************************/
	/* Creates various bits and pieces needed in the graphical part of the
	   display, works out how things need to be spaced, and then positions
	   them. */
	
	this._render();



	/**********************************************************************/
	/* Event callbacks. */

	window.addEventListener('load',   this.resize.bind(this));
	window.addEventListener('resize', this.resize.bind(this));
//	if (document.fonts && document.fonts.ready)
//	    document.fonts.ready.then(this.resize.bind(this));



	/**********************************************************************/
	/* Throttle to improve performance when scrolling the thing which
	   contains the duration lines. */
	
	const me = this;
	const container = _ClassCommon.getDatesAndLinesContainer();
	var durationScrollTimeout = null;
	container.addEventListener("scroll", () => {
	    if (durationScrollTimeout) return;
	    durationScrollTimeout = requestAnimationFrame(() => {
		me._checkDurationOverlaps();
		durationScrollTimeout = null;
	    });
	});




	/**********************************************************************/
	/* Arrange to respond to changes the user makes to the setting --
	   colours, font sizes, etc. */
	
	function fnUserSettingsChanged (firstTime)
	{
	    const background = getComputedStyle(document.documentElement).getPropertyValue("--clrBackground").trim();
	    const isDark = JFrameworkUtils.isDark(background);
	}
	JFrameworkUserSettings.init(fnUserSettingsChanged);



	/**********************************************************************/
	this._makeInitialSelection();
    }

	
    /**************************************************************************/
    /* We need to check when duration bars overlap the top of the graphics
       area so as to be able to update the div which tells the user about
       them. */
    
    _checkDurationOverlaps ()
    {
	/**********************************************************************/
	/* Does the header for a single item. */
	
	const durationHeaderContainer = _ClassCommon.getDurationHeaderContainer();
	const timeline = _ClassCommon.getTimeline();
	const linePosition = this._linePosition;
	var nDisplayableEntries = -1;
	
	function renderHeaderForItem (durationLineDiv)
	{
	    const entry = JChronologyData.getEntryGivenElement(durationLineDiv);
	    const channelNo = JChronologyData.getDurStartChannelNo(entry);
	    const line = document.createElement('div');
	    line.className = 'jchronologyDurationHeaderLine';

	    line.style.left = (2 + parseFloat(durationLineDiv.style.left)) + 'px'; // '+2' allows for left margin of some containers.
	    line.style.height = (1 + (1.5 * --nDisplayableEntries)) + 'em';

	    const label = document.createElement('div');
	    label.className = 'jchronologyDurationHeaderLabel';
	    label.textContent = JChronologyData.getDescription(entry);

	    var colour = getComputedStyle(durationLineDiv).backgroundColor;
	    line.style.borderLeftColor = colour;
	    label.style.color = colour;

	    const unifiedYear = JChronologyData.getUnifiedYear(entry);
	    const bracketingEntries = JChronologyData.findBracketingEntries(unifiedYear, 'event');
	    if (bracketingEntries.match)
	    {
		label.style.cursor = 'pointer';
		label.addEventListener('click', () => {
		    const key = JChronologyData.getKey(bracketingEntries.match);
		    const matchingDiv = JChronologyData.getEventDateAndMarkerDivGivenKey(key);
		    _JChronologyPresentationHandler.selectEvent(matchingDiv, true);
		});
	    }

	    
	    line.appendChild(label);
	    durationHeaderContainer.appendChild(line);
	}
	


	/**********************************************************************/
	/* We need to remove any existing lines and labels, but we need to
	   retain the overlay at the left which I use to hold the help
	   button. */
	
	const container = _ClassCommon.getDatesAndLinesContainer();
	const containerTop = container.getBoundingClientRect().top;

	Array.from(durationHeaderContainer.children).forEach(child => {
	    if (child.id !== 'jchronologyDurationHeadersButtonOverlay' && child.id !== 'jchronologyMenuButtonOverlay')
		child.remove();
	});



	/**********************************************************************/
	/* Find out which items, if any, need to be displayed. */
	
	const reports = [];
	this._durationLines.forEach(item => {
	    const rect = item.getBoundingClientRect();
	    const doReport = rect.top <= containerTop && rect.bottom > containerTop;
	    if (doReport)
		reports.push(item);
	});




	/**********************************************************************/
	/* Order elements by channel no. */

	function orderFn (durationLineDiv)
	{
	    const entry = JChronologyData.getEntryGivenElement(durationLineDiv);
	    return JChronologyData.getDurStartChannelNo(entry);
	}


	
	/**********************************************************************/
	nDisplayableEntries = reports.length;
	reports.sort((a, b) => orderFn(a) - orderFn(b));
	reports.forEach(item => {
	    renderHeaderForItem(item);
	});
    }

    
    /**************************************************************************/
    _render ()
    {
	console.time("renderTimeline");
	const durationDetails = JTimelineRenderer.renderTimeline(); // Maps start keys to the start/end divs which will demarcate the duration line.
	console.timeEnd("renderTimeline");

	const durationDetailsByUnifiedYear = new Map();
	for (const key of durationDetails.keys())
	{
	    const startAndEndDiv = durationDetails.get(key);
	    const entry = JChronologyData.getEntryGivenElement(startAndEndDiv[0]);
	    const unifiedYear = JChronologyData.getUnifiedYear(entry);

	    if (!durationDetailsByUnifiedYear.has(unifiedYear)) // Note that while no two _events_ share the same date, more than one duration can have the same start date, so we need a multimap here.
		durationDetailsByUnifiedYear.set(unifiedYear, []);
	    durationDetailsByUnifiedYear.get(unifiedYear).push(startAndEndDiv);
	}

	const sortedUnifiedYears = [...durationDetailsByUnifiedYear.keys()].sort((a, b) => a - b);
	for (const unifiedYear of sortedUnifiedYears)
	{
	    const startAndEndDivs = durationDetailsByUnifiedYear.get(unifiedYear);
	    startAndEndDivs.forEach( (item, index) => { this._renderDuration(item); });
	}
	
	this._checkDurationOverlaps();

	_JChronologyPresentationHandler.reselectEventOrNonEvent();
    }


    /**************************************************************************/
    /* There are some benefits to having these in the right hand column.
       However, if we want the durations to remain visible even when scrolling
       the right-hand column horizontally, it'll have to be the left. */
    
    _durationLines = [];
    _renderDuration (startAndEnd)
    {
	/**********************************************************************/
	/* Data from chronology database. */
	
	const dataEntry = JChronologyData.getEntryGivenElement(startAndEnd[0]);
	const colour = JChronologyData.getDurStartColour(dataEntry);
	const channelNo = JChronologyData.getDurStartChannelNo(dataEntry);
	const isRegency = JChronologyData.getDurStartIsRegency(dataEntry);



	/**********************************************************************/
	/* Relatively fixed information. */
	
	const verticalStartPos = parseFloat(startAndEnd[0].style.top);
	const verticalEndPos   = parseFloat(startAndEnd[1].style.top);



	/**********************************************************************/
	/* Create and position the div which will represent this duration. */
	
	const newLine = document.createElement('div'); this._durationLines.push(newLine);
	_ClassCommon.getDatesAndLinesContainer().appendChild(newLine);
	newLine.classList.add('jchronologyDurationLine');
	newLine.style.left = _ClassJChronologyUtilities.getChannelLeft(_ClassCommon.getTimeline(), channelNo) + 'px';
	newLine.style.background = colour;
	newLine.style.setProperty('--lineColour', colour); // We need this in order for CSS to draw the down-arrow at the start of the line in the correct colour.
	newLine.style.height = (verticalEndPos - verticalStartPos - parseFloat(_ClassCommon.getVerticalGapBetweenConsecutiveDurationLines())) + 'px'; // The parseFloat gives some space at the bottom of each line,
	                                                                                                                                                         // so that if one line ends and another starts at the same date,
 	                                                                                                                                                         // we can see a break between the two.
	newLine.style.top = `${verticalStartPos}px`;
	newLine.setAttribute('data-key', startAndEnd[0].getAttribute('data-key'));

	if (isRegency)
	    newLine.classList.add('regency');
//	    newLine.style.background = `repeating-linear-gradient(to bottom, ${colour} 0 10px, yellow 10px 20px)`;

	if (_ClassJChronologyUtilities.C_Dbg)
	{
	    const info = `Key: ${key}  Col: ${channelNo}  Top: ${verticalStartPos}  Bottom: ${verticalEndPos} Date: ${JChronologyData.getAnnotatedYearModernDate(dataEntry)}`;
	    console.log(info);
	    newLine.addEventListener('click', function (event) {
		alert(info);
	    });
	}
    }

    
    /**************************************************************************/
    _respondToFrameWidthChanges ()
    {
	if (this._updateFrameWidth())
	    this._render();
    }


    /**************************************************************************/
    /* Determines if the screen changes have resulted in the chronology frame
       going from 'wide' to 'narrow' or vice versa (sizes defined here).  If
       so, changes class settings in the body to deal with things whose
       visibilty has to depend upon frame width. */
    
    _updateFrameWidth ()
    {
	const containerWidth = parseFloat(window.getComputedStyle(_ClassCommon.getChronologyContainer()).width);
	if (containerWidth > 500)
	{
	    if (document.body.classList.contains('isWideScreen')) return false;
	    document.body.classList.remove('isNarrowScreen');
	    document.body.classList.add('isWideScreen');
	}
	else
	{
	    if (document.body.classList.contains('isNarrowScreen')) return false;
	    document.body.classList.add('isNarrowScreen');
	    document.body.classList.remove('isWideScreen');
	}

	return true;    }
}

export const JChronology = new _ClassJChronology();





/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                            Timeline renderer                             **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
class _ClassJTimelineRenderer
{
    /**************************************************************************/
    /* Configuration data.  This isn't intended to be changed dynamically:
       I have it here merely because I don't think we've necessarily pinned
       down all aspects of how we want the layout to work. */
    
    _additionalSpacingAfterSameYearAsPrevious = 0; // If we have two lines both for the same year (which is the most we can ever have) permits some extra spacing to be introduced after them.
    _gapBetweenLines = 6; // Space between consecutive text lines (px), to aid readability.
    _headerAndTrailerHeight = 20; // A short piece of timeline at top and bottom of the screen so that things don't cut off too abruptly.
    _mergeChapterEventsWithPreviousVanillaEvent = false;
    _suppressRepeatedDates = true;
    _suppressMarkersAndDatesForChapters = true;
    
    
    
    /**************************************************************************/
    /* I _think_ we want things left-aligned as far as possible, so as to give
       plenty of room for the description of the events.  This determines the
       maximum width required to contain the date labels, and then shifts
       everything to the left accordingly. */
    
    adjustPositionOfLine ()
    {
	/**********************************************************************/
	var maxDateWidth = 0;
	const dates = document.querySelectorAll('.jchronologyEventDate');
	dates.forEach(date => {
	    maxDateWidth = Math.max(maxDateWidth, date.offsetWidth);
	});



	/**********************************************************************/
	/* Adjust the markers to be centred on the timeline. */
	
	const markers = document.querySelectorAll('.jchronologyEventMarkerCircle');
	const markerStyle = window.getComputedStyle(markers[0]);
	const markerHalfWidth = parseFloat(markerStyle.width) / 2;
	const markerMargin = 2 * parseFloat(markerStyle.borderLeftWidth); // Not exactly sure why we need '2 *', but apparently we do.
	const markerLeft = (markerMargin - markerHalfWidth) + 'px';
	markers.forEach(marker => {
	    marker.style.left = markerLeft;
	});



	/**********************************************************************/
	/* Move the line. */

	const gapBetweenDateLabelsAndLine = 10;
	this._linePosition = maxDateWidth + gapBetweenDateLabelsAndLine;
	const line = _ClassCommon.getTimeline();
	line.style.left = `${this._linePosition}px`;



	/**********************************************************************/
	/* Make the width of the button overlay the same as the offset of the
	   timeline.  This then makes it possible to position the date help
	   button centrally over the dates. */
	
	_ClassCommon.getDurationHeadersButtonOverlay().style.width = line.style.left



	/**********************************************************************/
	/* Move the dates. */

	var separation = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--datesAndTimelineHorizontalSeparation'));
	dates.forEach(date => {
	    date.style.right = (gapBetweenDateLabelsAndLine + 2) + 'px'; // Not sure why the '2', bu it squares with a setting I'm using on the markers.
	});



	/**********************************************************************/
	/* Alter the width of the left-hand column to accommodate the dates,
	   timeline and duration lines.  The right hand column will
	   automatically follow. */
	
	const width = _ClassJChronologyUtilities.getChannelLeft(_ClassCommon.getTimeline(), 4);
	document.documentElement.style.setProperty('--chronologyTimelineWidth', width + 'px');
    }


    /**************************************************************************/
    /* Given a unified year, works out where to position it vertically. */
    
    rawPositionForAmDate (unifiedYear)
    {
	return this._headerAndTrailerHeight + unifiedYear * _ClassCommon.getVerticalSpacePerYearForAmDates();
    }

    rawPositionForNonAmDate (unifiedYear)
    {
	return this._lastPosInAm + (unifiedYear - this._lastUnifiedYearInAm) * _ClassCommon.getVerticalSpacePerYearForNonAmDates();
    }

    
    /**************************************************************************/
    /* The layout comprises two divs, side by side.  (One of these is created
       in the HTML; the other (the right-hand one) is created here on the
       fly for efficiency reasons -- see clearAndRecreateTargetElements
       below.)

       The left-hand div contains, for each event, the date label and the
       circle marker.  The vertical line which represents the timeline also
       goes here.

       The right-hand div contains the description of each event.

       The reason for splitting things this way is that I want to be able to
       have the description scroll horizontally if necessary, but I want the
       date details to remain fixed horizontally.

       This brings with it a complication, because I want just a single
       vertical scroll bar down the right of the right-hand div, but I have
       to arrange for this to scroll both divs at the same time.

       The entries which appear here are as follows:

       - AnnotatedYears have a date and a description.  These cover years
         for which we have event details (like the accession of monarchs
	 or whatever).  These I refer to as AnnotatedYears.  Where the
	 year in question also appears in our chapter-to-year data as
	 being a year which is coverted by one or more scripture chapters,
	 the scripture information also appears as part of the description.

       - There are 'chapter' lines, which indicate that a given collection
         of chapters are believed to cover a particular year.  These
	 appear only if the year in question does not have an AnnotatedYear
	 line.  (As mentioned above, where this is the case, the information
	 from the chapter line is merged into that for the AnnotatedYear.)

       - There are duration-start and duration-end events, which indicate
         when some enduring situation starts and ends -- the regnal
	 period for a king perhaps.

       - And there may be what I refer to here as tick marks.  These are
         regular indications of dates, mainly to help when scrolling
	 through wastelands where we have no other information.  Having
	 these labels displayed helps make it clear that the scrolling is
	 actually achieving something.


       AnnotatedYears and Chapter lines are visible and clickable.  Clicking
       on them causes the info box and scripture window to be updated to
       contain information about the year and / or the chapters.

       Duration -start and -end do not produce visible lines of text: rather,
       they give rise to vertical lines representing the duration in question.
       They occupy something of a shadow land.  It is convenient to include
       them in the processing as though they were genuine events, because then
       the re-rendering associated with resize events can arrange that they,
       too, are appropriately repositioned.  But we don't want them to be
       visible as though they were actual events, which I achieve via
       z-order, leaving their text content empty, and not given them a click
       handler.

       Tick marks are simply labels, and are not clickable.


       All entries have what I refer to as a unified year associated with
       them.  The unified year runs from zero for the date AM 0, and
       increases monotonically all the way up to the last event (at 90 AD).
       It takes care of the place where dates swap from AM to BC, and the
       values are arranged to mirror the chronological interval between
       events.  This means they can be used for ordering and positioning.

       In addition, AnnotatedYear items can be given a human-readable date
       drawn from one of a collection of alternative chronologies.  The
       particular chronology used for this is user-selectable at run time.
       
       We now come on to the matter of vertical positioning.  To a first
       approximation, we want to position each event proportionate to its
       unified year.  If it were actually that simple, 'all' we would need
       to do is decide how much vertical space to assign to every year
       from about 4004 BC to about 100 AD, based upon the font size
       currently in use, along with a little additional inter-line spacing
       to improve readability, and then position things according to
       their offset year.

       Needless to say, though, it's not that simple ...

       Over the AM period, events tend to be very sparse, and we would
       therefore end up with large chunks of timeline which were totally
       empty (but for tick marks).  And there is also the issue of what
       to do if two consecutive visible events (ie non-duration events)
       are so close to one another chronologically that their representations
       would overlap.

       The basic answer is that we do our best, and accept that at such
       points the proportional layout will go awry.

       The overall approach relies upon the ordering of the incoming
       data, which is by unified year, except that where several events
       carry the same unified year, the AnnotatedYear entry comes first,
       then any chapter entry, and then duration starts and ends.
    */
    
    _fontSizeInPx = -1;           // Updated during processing to follow the actual font size chosen by the user.
    _lastUnifiedYearInAm = -1;    // The unified year for the last event which falls into the AM portion.
    _lastPosInAm = -1;            // The position of the last visible event which falls into the AM portion.

    renderTimeline ()
    {
	/**********************************************************************/
	/* The individual elements are added to two elements -- the timeline
	   and the year descriptions container.  It turns out to be very
	   much quicker to do this if we create these two elements outside of
	   the document, then add everything to them, and only then place
	   the two elements within the document.  (Quicker by a factor of
	   almost five.)

	   clearAndRecreateTargetElements creates and records details of them.
	   registerTargetElements is called at the end of the present method
	   to add them to do the document and set them up. */

	function clearAndRecreateTargetElements ()
	{
	    _ClassCommon.getTimeline()?.remove();
	    _ClassCommon.getYearDescriptionsContainer()?.remove();
	    document.querySelectorAll('.jchronologyDurationLine').forEach(el => el.remove());
	    
	    var div = document.createElement('div');
	    div.id = 'jchronologyTimelineLine';
	    _ClassCommon.setTimeline(div);

	    var div = document.createElement('div');
	    div.id = 'jchronologyYearDescriptions';
	    _ClassCommon.setYearDescriptionsContainer(div);
	}

	function registerTargetElements ()
	{
	    _ClassCommon.getDatesAndLinesContainer().appendChild(_ClassCommon.getTimeline());
	    document.getElementById('jchronologyContainer').appendChild(_ClassCommon.getYearDescriptionsContainer());


	    /**********************************************************************/
	    /* The chronology display comprises two columns.  Only the right one
	       has a vertical scroll bar, but I need to arrange that if the user
	       scrolls, both are affected. */
	
	    const leftCol = document.getElementById('jchronologyDatesAndLines');
	    const rightCol = _ClassCommon.getYearDescriptionsContainer();

	    rightCol.addEventListener('scroll', () => {
		leftCol.scrollTop = rightCol.scrollTop;
	    });
	}
	
    

	/**********************************************************************/
	clearAndRecreateTargetElements();


	
	/**********************************************************************/
	const selectedAltChronology = _ClassAlternativeChronologies.makeChronologyKeyFromCache();
	_ClassAlternativeChronologies.displayActiveAlternativeChronologyName(selectedAltChronology);

	

	/**********************************************************************/
	/* Maps between key values and the div which represents them.  Start
	   off by emptying the map (obviously not necessary if the present
	   method is only ever called once, but in fact it may be called on
	   screen resize). */
	
	JChronologyData.clearKeyToElementsMapping();
	_ClassCommon.resetRootResolver();


	
	/**********************************************************************/
	/* Determine font size dynamically.  This is assumes that if we want
	   to follow user preferences, --defaultfont is indeed updated
	   elsewhere in line with any changes the user may make. */
	
	this._fontSizeInPx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--defaultFontSize').trim());


	
	/**********************************************************************/
	/* The AM events and the BC / AD events are subject to different
	   spacing regimes, so it's convenient to split them into two separate
	   lists. */
	
	function isAmEvent (event) { return JChronologyData.getUnifiedYear(event) <= JChronologyData.getLastUyearInAm(); }

	const [amEvents, bcAdEvents] = 
	      JChronologyData.getEntries()
	        .reduce(
		  ([pass, fail], elem) => {
		      return isAmEvent(elem)
			  ? [[...pass, elem], fail]
			  : [pass, [...fail, elem]];
		  },
		  [[], []]
	      );
    

	
	/**********************************************************************/
	var mostRecentUnifiedYear = -1;
	var mostRecentPos = -1;
	const durationMap = new Map();
	var rawPositionFunction = null;
	const eventDescriptionContainerDivs = [];
	var associatedChapterIx = -1;



	/**********************************************************************/
	/* We need to simulate the effect of separate columns when displaying
	   both the Ussher date and the Modern one.  This is most easily
	   achieved by left padding the Modern date with non-breaking
           spaces. */
	
	function padDate (s)
	{
	    const paddingNeeded = 7 - s.length;
	    return '&nbsp;'.repeat(paddingNeeded) + s;
	}


	
	/**********************************************************************/
        const doEvent = (e, type) =>
	{
	    /******************************************************************/
	    const isChapterEntry = JChronologyData.isChapterEntry(e); // A pseudo event assocated with the start of a chapter.
	    const isAnnotatedYearEntry = JChronologyData.isAnnotatedYearEntry(e);
	    const isVisibleEntry = !JChronologyData.isDurEntry(e);
	    const flags = isVisibleEntry ? JChronologyData.getFlags(e) : ''; // Tells us whether this is an approximate date, etc.
	    const key = JChronologyData.getKey(e);
	    const sameYearAsPrevious = mostRecentUnifiedYear == JChronologyData.getUnifiedYear(e);



	    /******************************************************************/
	    /* Work out where to put the tag ...

	       If this is an entry which the user will see on the
	       timeline, try positioning it as would be dictated by
	       the date of the event within the overall chronology.
	       If that would overlap with the most recent tag, move it
	       down a bit.  And either way, record the position so
	       that we can check for overlaps next time round.  We
	       also record the year offset for use with
	       duration processing. */

	    var pos = -1;
	    
	    if (isVisibleEntry)
	    {
		mostRecentUnifiedYear = JChronologyData.getUnifiedYear(e);
		pos = rawPositionFunction(mostRecentUnifiedYear);
		pos = Math.max(pos, mostRecentPos + _ClassCommon.getVerticalSpaceForDatesMinimumToAvoidOverlap());
		mostRecentPos = pos;
		if (sameYearAsPrevious) mostRecentPos += this._additionalSpacingAfterSameYearAsPrevious;
	    }



	    /******************************************************************/
	    /* Duration tags are different.  I do create them, because they
	       are useful to make the start and end of duration lines, such
	       that the positions can be readily updated with screen
	       resizing etc.  But they are invisible, and there is therefore
	       no problem if they overlap things -- and also the presence
	       of a duration tag does not get in the way of event tags.

	       So to get the easy bit out of the way first ... we _do_
	       need to work out a position, but we don't need to update
	       mostRecentUnifiedYear or mostRecentPos, because what we are
	       doing here is essentially invisible to the processing for
	       'real' events.

	       As regards the position, because the chronology data is
	       ordered by offset year, and further ordered so that if a
	       duration event shares the same date as a visible event, the
	       duration event always comes later in the ordering, we can
	       simply take the larger of the position given by the raw
	       chronology-based calculation and the most recent event
	       position. */

	    else // A duration tag.
	    {
		const unifiedYear = JChronologyData.getUnifiedYear(e);
		pos = Math.max(rawPositionFunction(unifiedYear), mostRecentPos);
		pos += this._fontSizeInPx / 2; // Positions the top of the duration by the vertical mid point of the text which describes it.
	    }



	    /******************************************************************/
	    /* This next block of code is basically common for event tags
	       and duration tags.  The only difference is that I don't add
	       click handlers to duration events, because they are a behind-
	       the-scenes artefact, which I want the user to be unaware of.

	       Here we are creating a div ('jchronologyEventDateAndMarkerHolder')
	       to hold the date label and the marker which marks the event.

	       We position the div, add a click handler if appropriate,
	       store within it the key for the data which it represents,
	       and record the association between that key and this div. */
	    
	    const eventDateAndMarkerDiv = document.createElement('div');
	    eventDateAndMarkerDiv.className = 'jchronologyEventDateAndMarkerHolder';
	    eventDateAndMarkerDiv.style.top = pos + 'px';
	    if (isVisibleEntry) eventDateAndMarkerDiv.addEventListener('click', () => JEventHandlers.eventClickHandler(eventDateAndMarkerDiv));
	    eventDateAndMarkerDiv.setAttribute('data-key', key);



	    /******************************************************************/
	    /* At one time I was potentially outputting more than one event
	       for the same date, and wanted to suppress the date label and
	       marker for the second and subsequent entries.  I am no longer
	       doing this, but I've retained the code just in case. */
	    
	    const suppressingDateAndMarker = false; // (this._suppressRepeatedDates && sameYearAsPrevious) || (isChapterEntry && this._suppressMarkersAndDatesForChapters);


	    
	    /******************************************************************/
	    /* Set up a div to hold the date label(s) and format it to reflect
	       the reliability of the date. */
	    
	    const dateDiv = document.createElement('div');
	    dateDiv.classList.add('jchronologyEventDate');

	    if (flags.includes('~'))
		dateDiv.classList.add('jchronologyDateApproximate');
	    else
		dateDiv.classList.add('jchronologyDateDefinite');
		



	    /******************************************************************/
	    /* Now for the content of the dateDiv.  For AnnotatedYears we
	       have both the secondary date (if one is selected) and the
	       Modern date.  For chapters and tick marks we have only the
	       Modern date.  For durations we have neither. */
	    
	    if (isChapterEntry)
		dateDiv.innerHTML = JChronologyData.getAnnotatedYearModernDate(e);
	    else if (isAnnotatedYearEntry)
	    {
		const altDate = `<span class='jchronologyDateAlternative' data-key='${key}'>` + JChronologyData.getField(e, selectedAltChronology) + '</span>';
		var modernDate = '<span style="color:red">&nbsp;' + padDate(JChronologyData.getAnnotatedYearModernDate(e)) + '</span>';
		dateDiv.innerHTML = altDate + modernDate;
	    }
	    
	    eventDateAndMarkerDiv.appendChild(dateDiv);



	    /******************************************************************/
	    /* Create the marker which goes on the timeline (not for
               durations). */
	    
	    const marker = document.createElement('div');
	    marker.className = 'jchronologyEventMarkerCircle';
	    eventDateAndMarkerDiv.appendChild(marker);
		
	    if (suppressingDateAndMarker)
	    {
		marker.style.visibility = 'hidden';
		dateDiv.style.visibility = 'hidden';
	    }
	    
	    _ClassCommon.getTimeline().appendChild(eventDateAndMarkerDiv);




	    /******************************************************************/
	    /* That's the content of the left-hand column pinned down.  We now
	       turn to the right-hand column which contains the event and
	       chapter descriptions.

	       In theory this can be a good deal simpler, because basically
	       all we need is text.  However, to mirror what I've done in the
	       left-hand column, I create a container div for the details --
	       jchronologyEventDescriptionHolder, and position that and
	       add a click handler if appropriate, and then place the text
	       within a div within that.

	       And actually, working out the content is fairly hairy too --
	       see below. */
	    
	    const eventDescriptionContainerDiv = document.createElement('div');
	    eventDescriptionContainerDivs.push(eventDescriptionContainerDiv);
	    
	    eventDescriptionContainerDiv.className = 'jchronologyEventDescriptionHolder';
	    eventDescriptionContainerDiv.style.top = pos + 'px';
	    if (isVisibleEntry) eventDescriptionContainerDiv.addEventListener('click', () => JEventHandlers.eventClickHandler(eventDescriptionContainerDiv));
	    eventDescriptionContainerDiv.setAttribute('data-key', key);
	
	    const descriptionDiv = document.createElement('div');
	    descriptionDiv.className = 'jchronologyEventDescription';
	    if (isChapterEntry) descriptionDiv.classList.add('jchronologyChapterEventDescription'); // Make a note if this is a chapter div.



	    /******************************************************************/
	    /* Time for the content etc.

	       If this is a pure chapter event, things are relatively easy --
	       we just want to convert it to 'pretty' form.

	       If this is a vanilla event, it's more complicated.  We want the
	       standard content, devoid of links.  But if there is an
	       associated chapter entry, we want the content from it to. */

	    var content = '';

	    if (isChapterEntry)
		content = '<span class="iconFont">K&nbsp;</span>' + this._convertToRanges(JChronologyData.getChapterRefs(e));
	    else if (isAnnotatedYearEntry)
	    {		
		content = JChronologyData.withoutLinks(JChronologyData.getDescription(e)); // We don't want person and place links in the event description.  They will be available
		                                                                           // in the info-box, and in the event description they'll get in the way of click handling.
		const scriptureRefs = JChronologyData.getChaptersFromChapterAndYearDataAsString(e);
		if ('' != scriptureRefs) content += '&nbsp;&nbsp;<span class="iconFont">K&nbsp;</span>' + scriptureRefs;

		if (flags.includes('↑'))
		    content = '↑&nbsp;' + content
		else if (flags.includes('↓'))
		    content = '↓&nbsp;' + content
	    }

	    if (isVisibleEntry) descriptionDiv.insertAdjacentHTML('beforeend', _ClassJChronologyUtilities.withDurationColours(content)); // Colour any down arrows to follow the duration lines.

	    eventDescriptionContainerDiv.appendChild(descriptionDiv); // Add the text container to the event container.
	    _ClassCommon.getYearDescriptionsContainer().appendChild(eventDescriptionContainerDiv); // And add the individual event container to the overall container for the right hand column.
	    
	    marker.style.top = ((parseFloat(getComputedStyle(descriptionDiv).height) - parseFloat(getComputedStyle(marker).height)) / 2) + 'px'; // Centre vertically.



	    /******************************************************************/
	    /* I've been asked to highlight the selected item by setting its
	       bacground colour.  It looks neater if the background bars are
	       the full width of the right-hand pane. */
	    
	    for (const div of eventDescriptionContainerDivs)
		div.style.width = _ClassCommon.getYearDescriptionsContainer().scrollWidth + "px";


	    
	    /******************************************************************/
	    /* A non-visible event is a duration.  We need to record the fact
	       by way of class settings. */
	    
	    if (!isVisibleEntry)
	    {
		dateDiv.classList.add('jchronologyDurationElement');
		marker.classList.add('jchronologyDurationElement');
		
		eventDateAndMarkerDiv.classList.add('jchronologyDurationElement');
		eventDescriptionContainerDiv.classList.add('jchronologyDurationElement');
		descriptionDiv.classList.add('jchronologyDurationElement');

		if (JChronologyData.isDurStartEntry(e))
		    durationMap.set(JChronologyData.getKey(e), eventDateAndMarkerDiv) // Temporarily this maps the key of the duration-start to the hidden div which marks the start.
		else
		{
		    const key = JChronologyData.convertDurationEndKeyToStartKey(JChronologyData.getKey(e));
		    const start = durationMap.get(key);
		    durationMap.set(key, [start, eventDateAndMarkerDiv]); // This now replaces the temporary entry with one which maps the key of the duration-start to the pair of hidden divs which mark the start and end.
		}
	    }



	    /******************************************************************/
	    JChronologyData.recordElementsForKey(key, { eventDateAndMarkerDiv: eventDateAndMarkerDiv,
							dateDiv: dateDiv,
							marker: marker,
							eventDescriptionContainerDiv: eventDescriptionContainerDiv,
							eventDescriptionDiv: descriptionDiv
						      });
	} // doEvent


	
	/**********************************************************************/
	/* Deal first with the 'AM' events.  The raw position of these is
	   reasonably easy, because AM simply runs forward from 0, so the
	   position is determined by leaving a bit of a gap for the header,
	   and then just converting the unified year proportionately to a
	   number of pixels.  (This initial raw position may then be adjsted
	   to avoid overlaps.) */
	
	rawPositionFunction = this.rawPositionForAmDate.bind(this);
	for (const e of amEvents)
	    doEvent(e, 'AM')



	/**********************************************************************/
	/* This makes it possible to have a different spacing for BC events,
	   on the grounds that in the main they are rather closer together.
	   Whether this helps is, perhaps, dubious.  If you make them far
	   enough apart to reduce the number of overlaps (and therefore to
	   make the spacing more proportionate), you end up with some huge
	   gaps. */

	this._lastPosInAm = mostRecentPos;
	this._lastUnifiedYearInAm = mostRecentUnifiedYear;
	rawPositionFunction = this.rawPositionForNonAmDate.bind(this);
	for (const e of bcAdEvents)
	    doEvent(e, 'BCAD')
	
	

	/**********************************************************************/
	registerTargetElements();
	this._addTickMarks();


	
	/**********************************************************************/
	/* Add a pseudo marker which can be used when invoked with a date which
	   doesn't feature in the list of events. */
	
	const marker = document.createElement('div');
	marker.classList.add('jchronologyEventMarkerDiamond', 'jchronologyEventMarkerHighlight');
	marker.style.display = 'none';
	_ClassCommon.setArbitraryDateMarker(marker);
	_ClassCommon.getTimeline().appendChild(marker);
	_JChronologyPresentationHandler.reselectNonEvent();



	/**********************************************************************/
	_ClassCommon.getTimeline().style.height = (mostRecentPos + 2 * this._headerAndTrailerHeight) + 'px';
	this.adjustPositionOfLine();
	return durationMap;
    } // renderTimeline


    /**************************************************************************/
    _addTickMarks ()
    {
	/**********************************************************************/
	/* Gets a list of the tops and bottoms of all date labels.  This needs
	   some care.  You can't use .jchronologyEventDate, because the 'top'
	   value for that is always zero.  .jchronologyEventDateAndMarkerHolder
	   is ok for the tops, but it doesn't give the height, so I need to
	   take a fixed value for that. */
	
	const labelHeight = document.getElementById('getLabelSizeForTickMarks').offsetHeight;
	const timeline = _ClassCommon.getTimeline();
	const mainFontSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--defaultFontSize').trim());
	const existingDateLabelIntervals = [...document.querySelectorAll('.jchronologyEventDateAndMarkerHolder')]
	      .map(el => {
		  var top = el.offsetTop;
		  var bottom = top + mainFontSize + 2;
		  return { top, bottom };
	      })
	      .sort((a, b) => a.top - b.top);



	/**********************************************************************/
	/* Looks for a clash between the putative new element and any of the
	   original date labels. */
	
	function clash (intervals, newTop, newBottom)
	{
	    var lo = 0;
	    var hi = intervals.length - 1;

	    while (lo <= hi)
	    {
		const mid = (lo + hi) >> 1;
		const cur = intervals[mid];

		if (newBottom < cur.top)
		    hi = mid - 1; // new element is above this interval
		else if (newTop > cur.bottom)
		    lo = mid + 1; // new element is below this interval
		else 
		    return true; // OVERLAP FOUND
	    }
	    return false;
	}


	/**********************************************************************/
	/* Constructs a tick mark element, but does not insert it into the
	   DOM -- the caller deals with that. */
	
	function makeElement (pos, label)
	{
	    const eventDateAndMarkerDiv = document.createElement('div');
	    eventDateAndMarkerDiv.className = 'jchronologyEventDateAndMarkerHolder';
	    eventDateAndMarkerDiv.style.top = pos + 'px';
	    const dateDiv = document.createElement('div');
	    dateDiv.classList.add('jchronologyEventDate');
	    dateDiv.classList.add('jchronologyTickMarkDateLabel');
	    dateDiv.innerHTML = label;
	    eventDateAndMarkerDiv.appendChild(dateDiv);
	    timeline.appendChild(eventDateAndMarkerDiv);
	    return eventDateAndMarkerDiv;
	}



	/**********************************************************************/
	const me = this;
	function makeAmPos (uyear)
	{
	    return me.rawPositionForAmDate(uyear) + labelHeight / 2;
	}

	function makeBcPos (year)
	{
	    const uyear = JChronologyData.getAdBcOffset() - year;
	    return me.rawPositionForNonAmDate(uyear) + labelHeight / 2;
	}

	function makeAdPos (year)
	{
	    const uyear = JChronologyData.getAdBcOffset() + year;
	    return me.rawPositionForNonAmDate(uyear) + labelHeight / 2;
	}


	
	/**********************************************************************/
	const C_AmInterval = 50;
	var start = 0;
	var uyear = 0;
	while (uyear < JChronologyData.getFirstUYearBc())
	{
	    const pos = makeAmPos(uyear);
	    const newDiv = makeElement(pos, 'AM ' + uyear);
	    if (clash(existingDateLabelIntervals, pos - labelHeight, pos + labelHeight))
		newDiv.remove()
	    uyear += C_AmInterval;
	}


	
	/**********************************************************************/
	const C_BcInterval = 5;
	var year = Math.floor( (1 + JChronologyData.getFirstUYearBc()) / C_BcInterval) * C_BcInterval;
	while (year >= 0)
	{
	    const pos = makeBcPos(year);
	    const newDiv = makeElement(pos, year + ' BC');
	    if (clash(existingDateLabelIntervals, pos - labelHeight, pos + labelHeight))
		newDiv.remove()
	    year -= C_BcInterval;
	}


	
	/**********************************************************************/
	const C_AdInterval = 5;
	var year = C_AdInterval;
	while (year < JChronologyData.getLastAsActualYear())
	{
	    const pos = makeAdPos(year);
	    const newDiv = makeElement(pos, year + ' AD');
	    if (clash(existingDateLabelIntervals, pos - labelHeight / 2, pos + labelHeight / 2))
		newDiv.remove()
	    year += C_AdInterval;
	}
    }


    
    /**************************************************************************/
    /* Courtesy of ChatGPT.  This is used when displaying, on the timeline,
       details of the chapters which refer to events in a given year.  We often
       have several consecutive chapters, and rather than display each
       individually, I convert them to ranges. */
    
    _convertToRanges (input)
    {
	// Split the input string into chunks
	const chunks = input.map(sublist => sublist[0]);

	// Parse into { prefix, num }
	const items = chunks.map(s => {
	    const [prefix, numStr] = s.split(".");
	    return { prefix, num: parseInt(numStr, 10) };
	});

	const result = [];
	var start = items[0];
	var last = items[0];

	for (var i = 1; i <= items.length; i++)
	{
	    const curr = items[i];
	    if (curr   &&   curr.prefix === last.prefix   &&   curr.num === last.num + 1)
		last = curr; // Still in the same sequential run.
	    else
	    {
		// End of current run
		if (start.num === last.num)
		    result.push(`${start.prefix}.${start.num}`);
		else
		    result.push(`${start.prefix}.${start.num}-${last.num}`);
		
		start = curr;
		last = curr;
	    }
	}

	return result.join("; ");		
    }
}

const JTimelineRenderer = new _ClassJTimelineRenderer();




/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                            Controls and menus                            **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                             Click handler                                **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
class _ClassJEventHandlers
{
    /**************************************************************************/
    alternativeChronologiesSelectorCancel (event)
    {
	this.hideDateHelp();
    }


    /**************************************************************************/
    alternativeChronologiesSelectorOk (type)
    {
	if ("Ussher" == type)
	    _ClassAlternativeChronologies.selectUssher();
	else
	    _ClassAlternativeChronologies.selectOther();
	this.hideDateHelp();
    }

    
    /**************************************************************************/
    /* Selects a plain vanilla or chapter event on the timeline. */
    
    eventClickHandler (eventDiv)
    {
	_JChronologyPresentationHandler.selectEvent(eventDiv, false);
    }

    
    /**************************************************************************/
    handleLink (event)
    {
	const tag = event.target;
	switch (tag.getAttribute('data-type'))
	{
	    case 'L': { JFrameworkStepDataAccessors.strongLinkToMap      (tag); break; }
	    case 'P': { JFrameworkStepDataAccessors.strongLinkToGenealogy(tag); break; }
	    case 'S': { _JChronologyPresentationHandler.setScriptureWindowContent(tag.dataset.ref, true); break; }
	}
    }


    /**************************************************************************/
    hideDateHelp ()
    {
	const modal = document.getElementById('dateHelp');
	ModalDialogHandler.closeIfTopModalDialog(modal);
    }


    /**************************************************************************/
    hideWelcomeDialog ()
    {
	ModalDialogHandler.closeIfTopModalDialog(document.getElementById('welcomeDialog'));
    }

    
    /**************************************************************************/
    showDateHelp ()
    {
	_ClassAlternativeChronologies.init();
	const modal = document.getElementById('dateHelp');
	ModalDialogHandler.showModalDialog(modal);
	modal.querySelector('.jframework-modalDialogBody').scrollTop = 0;
	modal.style.top = '20px';
	modal.style.left = (window.innerWidth - modal.offsetWidth) / 2 + 'px';
    }

  
    /**************************************************************************/
    showHelpMenu ()
    {
	const modal = document.getElementById('help');
	ModalDialogHandler.showModalDialog(modal);
	modal.querySelector('.jframework-modalDialogBody').scrollTop = 0;
	modal.style.top = '20px';
	modal.style.left = (window.innerWidth - modal.offsetWidth) / 2 + 'px';
	modal.scrollTop = 0;
    }

  
    /**************************************************************************/
    showLayoutMenu ()
    {
	const modal = document.getElementById('layoutMenu')

	ModalDialogHandler.showModalDialog(modal);

	modal.style.top = '20px';
	modal.style.left = (window.innerWidth - modal.offsetWidth) / 2 + 'px';

	document.getElementById('horizontalSpacingSlider').value = CurrentHorizontalSpacingTicks;
	document.getElementById('verticalSpacingSlider').value = CurrentVerticalSpacingTicks;
	document.getElementById('numberOfGenerationsSlider').value = CurrentNumberOfGenerationsToGrowByOnEachExpansion;
    }


    /**************************************************************************/
    showWelcome ()
    {
	this.showHelpMenu();
    }

  
    /**************************************************************************/
    updateScriptureWindow (tag)
    {
	_JChronologyPresentationHandler.setScriptureWindowContent(tag.textContent.replace('?', ''), true);
    }
}

export const JEventHandlers = new _ClassJEventHandlers();
window.JEventHandlers = JEventHandlers;




    
/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                           Presentation handler                           **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
class _ClassAlternativeChronologies
{
    /**************************************************************************/
    static _existingChronologyKey = '';


    /**************************************************************************/
    static displayActiveAlternativeChronologyName (chronologyName)
    {
	var s = chronologyName.replace('dt_', '');
	if (s.includes('_'))
	{
	    var x = s.split('_');
	    x[0] = x[0] + ' dates'
	    x[1] = 'Egypt yrs: ' + x[1];
	    x[2] = 'Exodus C' + x[2] + ' BC';
	    s = x.join('<br>');
	}
	
	document.getElementById('activeAlternativeChronologyName').innerHTML = s;
    }

    
    /**************************************************************************/
    /* Sets the radio buttons to reflect the cache. */
    
    static init ()
    {
	const me = this;
	function setRadioButtonsFromCache (cacheKey)
	{
	    const cacheValue = me._getValueFromCache(cacheKey);
	    const radio = document.querySelector(`input[type='radio'][name='${cacheKey}'][value='${cacheValue}']`);
            radio.checked = true;
	}
	    
	
	setRadioButtonsFromCache('DateCategory');
	setRadioButtonsFromCache('YearsInEgypt');
	setRadioButtonsFromCache('ExodusDate');
    }


    /**************************************************************************/
    static makeChronologyKeyFromCache ()
    {
	if ('y' == localStorage.getItem('chronologyUssher', 'n'))
	    return 'dt_Ussher';
	else
	    return 'dt_' + this._getValueFromCache('DateCategory') + '_' + this._getValueFromCache('YearsInEgypt') + '_' + this._getValueFromCache('ExodusDate');
    }

    
    /**************************************************************************/
    static selectOther ()
    {
	this._saveRadioButtonsToCache();
	localStorage.setItem('chronologyUssher', 'n');
	const chronologyKey = this.makeChronologyKeyFromCache();
	this._updateDateColumn(chronologyKey);
    }


    /**************************************************************************/
    static selectUssher ()
    {
	localStorage.setItem('chronologyUssher', 'y');
	this._updateDateColumn('dt_Ussher');
    }

    
    /**************************************************************************/
    static _getDflt (cacheKey)
    {
	switch (cacheKey)
	{
	    case 'DateCategory': return 'Hebrew';
	    case 'YearsInEgypt': return '400';
	    case 'ExodusDate'  : return '15';
	}
    }

    
    /**************************************************************************/
    static _getRadioButtonValue (cacheKey)
    {
	return document.querySelector(`input[name='${cacheKey}']:checked`).value;
    }


    /**************************************************************************/
    static _getValueFromCache (cacheKey)
    {
	return localStorage.getItem(`chronology${cacheKey}`) ?? this._getDflt(cacheKey);
    }


    /**************************************************************************/
    static _makeChronologyKeyFromRadioButtons ()
    {
	return 'dt_' + this._getRadioButtonValue('DateCategory') + '_' + this._getRadioButtonValue('YearsInEgypt') + '_' + this._getRadioButtonValue('ExodusDate');
    }


    /**************************************************************************/
    static _saveRadioButtonsToCache ()
    {
	const me = this;
	function setCacheFromRadioButtons (buttonKey)
	{
	    localStorage.setItem('chronology' + buttonKey, me._getRadioButtonValue(buttonKey));
	}

	setCacheFromRadioButtons('DateCategory');
	setCacheFromRadioButtons('YearsInEgypt');
	setCacheFromRadioButtons('ExodusDate');
    }


    /**************************************************************************/
    static _updateDateColumn (chronologyKey)
    {
	this.displayActiveAlternativeChronologyName(chronologyKey);
	
	const tags = document.getElementsByClassName('jchronologyDateAlternative');
	for (const tag of tags)
	{
	    const key = tag.getAttribute('data-key');
	    if (!key) continue;
	    const revisedContent = JChronologyData.getField(JChronologyData.getEntryGivenKey(key), chronologyKey);
	    tag.innerHTML = revisedContent;
	}
	
	JTimelineRenderer.adjustPositionOfLine();
    }
}





/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                           Presentation handler                           **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
class _ClassJChronologyPresentationHandler
{
    /**************************************************************************/
    _preferredYearRepresentation = 'Modern';
    preferredYearIsModern () { return 'M' == this._preferredYearRepresentation[0]; }
    preferredYearIsUssher () { return 'U' == this._preferredYearRepresentation[0]; }

    
    /**************************************************************************/
    _selectedEventDiv = null;
    _selectedEventYear = null;
    _selectedNonEventPos = null;
    
    

    /**************************************************************************/
    /* Mainly intended for things like resizing, when we may end up doing a
       fair bit of redrawing, and may want to ensure that the original event
       is still selected. */
    
    reselectEventOrNonEvent ()
    {
	if (null !== this._selectedEventDiv)
	    this.selectEvent(this._selectedEventDiv);
	else
	    this.reselectNonEvent();
    }
    
    
    /**************************************************************************/
    reselectNonEvent ()
    {
	if (null !== this._selectedNonEventPos)
	    this.selectNonEvent(this._selectedNonEventPos);
    }

    
    /**************************************************************************/
    /* Updates info box, highlighting, etc, when a new selection is made. */
    
    selectEvent (eventDiv, centreSelection = true)
    {
	_ClassCommon.getArbitraryDateMarker().style.display = 'none';
	
	const entry = JChronologyData.getEntryGivenElement(eventDiv);
	const isChapterEntry = JChronologyData.isChapterEntry(entry);
	
	if (isChapterEntry)
	{
	    const refs = JChronologyData.getChapterRefsAsString(entry);
	    this.setScriptureWindowContent(refs.split('; ')[0], false);
	    this._setInfoBoxContentForChapterEvent(entry);
	}
	else
	{
	    this.setScriptureWindowContent(JChronologyData.getAnnotatedYearScriptureRefs(entry), false);
	    this._setInfoBoxContentForStandardEvent(entry);
	}
	


	const newKey = JChronologyData.getKey(entry);
	const thisMarker = JChronologyData.getMarkerGivenKey(newKey);
	const thisDescription = JChronologyData.getEventDescriptionDiv(newKey);

	const oldKey = null === this._selectedEventDiv ? null : this._selectedEventDiv.getAttribute('data-key');
	const oldMarker = null === oldKey ? null : JChronologyData.getMarkerGivenKey(oldKey);
	const oldDescription = null === oldKey ? null : JChronologyData.getEventDescriptionDiv(oldKey);

	if (null !== oldKey)
	{
	    oldMarker.classList.remove('jchronologyEventMarkerHighlight');
	    oldDescription.classList.remove('jchronologyEventMarkerHighlight');
	}

	
	this._selectedEventDiv = eventDiv;
	thisMarker.classList.add('jchronologyEventMarkerHighlight');
	thisDescription.classList.add('jchronologyEventMarkerHighlight');

	this._selectedEventDiv = eventDiv;
	this._selectedEventYear = JChronologyData.getAnnotatedYearModernDate(entry).replace(' ', '');

	if (centreSelection)
	    JFrameworkUtils.centrePointVerticallyWithinScrollingContainer(_ClassCommon.getYearDescriptionsContainer(), this._selectedEventDiv.style.top);
    }


    /**************************************************************************/
    selectNonEvent (pos)
    {
	this._selectedEventDiv = null;
	this._selectedNonEventPos = pos;
	const marker = _ClassCommon.getArbitraryDateMarker();
	marker.style.top = pos + 'px';
	marker.style.display = 'block';
	JFrameworkUtils.centrePointVerticallyWithinScrollingContainer(_ClassCommon.getYearDescriptionsContainer(), pos);
    }


    /**************************************************************************/
    setScriptureWindowContent (scriptures, forceScripturePaneVisible)
    {
	if ('' === scriptures) return;
	JFrameworkMultiframeCommunicationsSlave.sendSetUrlForce('scripture', window.location.origin + '/?skipwelcome&q=' + 'reference=' + scriptures + '&options=VHN&noredirect');

	if (forceScripturePaneVisible)
	    JChronology.sendMessageTo('scripture', { forceTabVisible: 'scripture' }, 'chronology');
    }


    /**************************************************************************/
    _copyLinkToClipboard ()
    {
	const entry = JChronologyData.getEntryGivenElement(this._selectedEventDiv);
	const key = JChronologyData.getKey(entry);
	const type = key.startsWith('EC') ? '&type=chapter' : '&type=event';
	const url = JFrameworkUtils.getFullUrl('html/J_AppsHtml/J_Chronology/j_chronologySplit3.html?year=' + this._selectedEventYear + type);
	navigator.clipboard.writeText(url);
	this._showPopUp('URL copied to clipboard', 'copyToClipboardConfirmation');
    }

	

    /**************************************************************************/
    /* Returns the info box with lazy evaluation. */
    
    _getInfoBox ()
    {
	if (!this.hasOwnProperty('_infoBox'))
	    this._infoBox = document.getElementById('info-box');
	return this._infoBox;
    }

    
    /**************************************************************************/
    /* Fills the info box for a pseudo event which represents a collection of
       sceripture dates associated with the given chapter. */
    
    _setInfoBoxContentForChapterEvent (entry, initialContent = '')
    {
	/**********************************************************************/
	const infoBox = this._getInfoBox();
	const date = ''; // '<br><b>' + JChronologyData.getAnnotatedYearModernDate(entry) + ':</b> ';
	const refs = JChronologyData.getChapterRefsAsString(entry);
	const caveatsA = refs.includes('?') ? ' (Question marks against references highlight chapters whose dates are particularly open to debate.)' : '';


	
	/**********************************************************************/
	(async () => {
	    var content = initialContent + '<br>'; // date + intro + '<br><br>';
	    for (const chapterRef of refs.split('; '))
	    {
		const link = _ClassJChronologyUtilities.withChapterScriptureLinks(chapterRef);
		var associatedText = await JFrameworkChapterSummaries.instance().getChapterSummary(chapterRef);
		if (!associatedText) associatedText = '&mdash;';
		associatedText = JChronologyData.withLinks(associatedText);
		associatedText = '<p>' + link + ': ' + associatedText.replaceAll('¶', '</p><p class="indentedPara">') + '</p><br>';
		content += associatedText;
	    }

	    content = content.slice(0, -4);

	    infoBox.innerHTML =
		`<div style='display:flex; align-items:center'>
                  <span id='shareableLink' class='jframework-linkAsButton' style='margin-left:auto' title='Copy to clipboard a URL for this event'>Shareable link</span>
                </div>
                ${content}`;
	})();
	


	/**********************************************************************/
	infoBox.querySelector('#shareableLink').addEventListener('click', () => this._copyLinkToClipboard());



	/**********************************************************************/
	infoBox.scrollTop = 0;
    }
    

    /**************************************************************************/
    /* Does what it says on the tin. */
    
    _setInfoBoxContentForStandardEvent (entry)
    {
	const infoBox = this._getInfoBox();
	const date = JChronologyData.getAnnotatedYearModernDate(entry);
	const shortDescription = JChronologyData.withLinks(JChronologyData.getDescription(entry));
	const scriptures = JChronologyData.getAnnotatedYearScriptureRefs(entry);
	const extraBiblicalRefs = JChronologyData.getAnnotatedYearNonScriptureRefs(entry);
	const longDescription = JChronologyData.getAnnotatedYearArticle(entry);

	var caveatsA = '';
	var caveatsB = '';
	if (JChronologyData.getFlags(entry).includes('~')) caveatsA = 'Date is approximate.';
	if (JChronologyData.getFlags(entry).includes('*')) caveatsB = 'This event is one of a collection which different chronologies place in different orders.';

	if ('' !== caveatsA && '' !== caveatsB) caveatsA += '<br>';
	caveatsA += caveatsB;
	if ('' !== caveatsA) caveatsA = '<br><br>' + caveatsA;

	(async () => {
	    var chapterSummaries = '';
	    const chaptersFromChapterAndYearData = JChronologyData.getChaptersFromChapterAndYearData(entry);
	    for (const chapterThunk of chaptersFromChapterAndYearData)
	    {
		const link = _ClassJChronologyUtilities.withChapterScriptureLinks(chapterThunk.ref);
		var associatedText = await JFrameworkChapterSummaries.instance().getChapterSummary(chapterThunk.ref);
		if (!associatedText) continue;
		associatedText = JChronologyData.withLinks(associatedText);
		associatedText = '<p>' + link + ': ' + associatedText.replaceAll('¶', '</p><p class="indentedPara">') + '</p><br>';
		chapterSummaries += associatedText;
	    }
	    

	    var content = '<b>' + date + ': ' + shortDescription + (shortDescription.endsWith('.') ? '' : '.') + '</b>' + caveatsA + '<br><br>';
	    if ('' != scriptures) content += '<b>Scripture references:</b> ' + scriptures + '<br><br>';
	    if ('' != extraBiblicalRefs) content += '<b>External references:</b> ' + extraBiblicalRefs + '<br><br>';
	    content += longDescription;
	    content += (chapterSummaries == '' ? '' : '<br><br>') + chapterSummaries;

	    infoBox.innerHTML =
		`<div style='display:flex; align-items:center'>
                  <span id='shareableLink' class='jframework-linkAsButton' style='margin-left:auto' title='Copy to clipboard a URL for this event'>Shareable link</span>
                </div>
                ${content}`;

	    infoBox.querySelector('#shareableLink').addEventListener('click', () => this._copyLinkToClipboard());
	    
	    infoBox.scrollTop = 0;
	})();
    }
    

    /**************************************************************************/
    _showPopUp (message, popUpId, duration = 1000)
    {
	const popup = document.getElementById(popUpId);
	popup.textContent = message;
	popup.style.display = "block";
	popup.style.opacity = "1";

	// Fade out after 'duration' milliseconds
	setTimeout(() => {
	    popup.style.opacity = "0";
	    setTimeout(() => {
		popup.style.display = "none";
	    }, 1000); // Wait for fade-out transition to finish
	}, duration);
    }
}

const _JChronologyPresentationHandler = new _ClassJChronologyPresentationHandler();





/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                                Utilities                                 **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
class _ClassJChronologyUtilities
{
    /**************************************************************************/
    static C_Dbg = false;
    static C_DurationColours = ['black', 'blue', 'green', 'red' ]; // DIB's preferred scheme, chosen to make similarities obvious.


    /**************************************************************************/
    /* Each channel is of the same width, and is separated from its left
       neighbour by a standard gap.  In addition, it may perhaps be useful to
       have this same gap between the timeline and the first channel. Change
       the '0' below to cater. */
    
    static getChannelLeft (timeline, channelNo)
    {
	const durationLineWidth= this.getDurationLineWidth();
	const durationLineSeparation = this.getDurationLinesHorizontalSeparation();
	const horizontalBasePos = durationLineSeparation + parseFloat(getComputedStyle(timeline).left) + parseFloat(getComputedStyle(timeline).width);
	return 0 + (horizontalBasePos + channelNo * (durationLineWidth + durationLineSeparation));
    }

    
    /**************************************************************************/
    static getDurationLinesHorizontalSeparation ()
    {
	return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--durationLinesHorizontalSeparation'));
    }

    
    /**************************************************************************/
    static getDurationLineWidth ()
    {
	return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--durationLineWidth'));
    }

    
    /**************************************************************************/
    /* The yearDescription field may contain down-arrows, linking it to the
       duration lines.  The link is establised using colours.  Links are marked
       in the incoming data by jChronDurationLinktags - all we need do here is
       convert them to spans. */
    
    static withDurationColours (s)
    {
	return s.replaceAll('jChronDurationLink', 'span');
    }

    
    /**************************************************************************/
    /* Takes the data associated with a chapter pseudo event and returns
       something which makes the individual scriptures clickable. */
    
    static withChapterScriptureLinks (s)
    {
	return '<span class="jframework-linkAsButton" onclick="JEventHandlers.updateScriptureWindow(this)">' + s + '</span>';
    }
}





/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                            Important elements                            **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/* Things which are possibly going to be required quite frequently.  The idea
   is that I do lazy evaluation here, so I find the relevant elements only
   when they are needed, and then do not need to rescan the DOM if they are
   needed again. */

class _ClassCommon
{
    /**************************************************************************/
    static _alternativeChronologiesSelector = null;
    static getAlternativeChronologiesSelector () // The portion of the graphics area which holds the year descriptions.
    {
	if (null === _ClassCommon._alternativeChronologiesSelector)
	    _ClassCommon._alternativeChronologiesSelector = document.getElementById('alternativeChronologiesSelector');
	return _ClassCommon._alternativeChronologiesSelector;
    }


    /**************************************************************************/
    static _arbitraryDateMarker = null;
    static getArbitraryDateMarker () { return _ClassCommon._arbitraryDateMarker; } // The marker used when asked to select a date which does not exist in hte events list.
    static setArbitraryDateMarker (marker) { _ClassCommon._arbitraryDateMarker = marker; }


    /**************************************************************************/
    static _chronologyContainer = null;
    static getChronologyContainer () // The div which holds the whole of the lower part of the screen.
    {
	if (null === _ClassCommon._chronologyContainer)
	    _ClassCommon._chronologyContainer = document.getElementById('jchronologyContainer');
	return _ClassCommon._chronologyContainer;
    }


    /**************************************************************************/
    static _datesAndLinesContainer = null;
    static getDatesAndLinesContainer () // The div which holds the timeline and associated graphics.
    {
	if (null === _ClassCommon._datesAndLinesContainer)
	    _ClassCommon._datesAndLinesContainer = document.getElementById('jchronologyDatesAndLines');
	return _ClassCommon._datesAndLinesContainer;
    }


    /**************************************************************************/
    static _durationHeaderContainer = null;
    static getDurationHeaderContainer () // The div at the top of the graphics area which gives headers for things only partially visible.
    {
	if (null === _ClassCommon._durationHeaderContainer)
	    _ClassCommon._durationHeaderContainer = document.getElementById('jchronologyDurationHeaders');
	return _ClassCommon._durationHeaderContainer;
    }


    /**************************************************************************/
    static _durationHeadersButtonOverlay = null;
    static getDurationHeadersButtonOverlay () // An overlay to getDurationHeaderContainer which holds the help button.
    {
	if (null === _ClassCommon._durationHeadersButtonOverlay)
	    _ClassCommon._durationHeadersButtonOverlay = document.getElementById('jchronologyDurationHeadersButtonOverlay');
	return _ClassCommon._durationHeadersButtonOverlay;
    }
    

    /**************************************************************************/
    static _timeline = null;
    static getTimeline () { return _ClassCommon._timeline; } //  Will be set to the actual vertical line which represents the timeline.
    static setTimeline (div) { _ClassCommon._timeline = div; }


    /**************************************************************************/
    static _verticalGapBetweenConsecutiveDurationLines = null;
    static getVerticalGapBetweenConsecutiveDurationLines ()
    {
	if (null === this._verticalGapBetweenConsecutiveDurationLines)
	    this._verticalGapBetweenConsecutiveDurationLines = getComputedStyle(document.documentElement).getPropertyValue('--verticalGapBetweenConsecutiveDurationLines');
	return this._verticalGapBetweenConsecutiveDurationLines
    }


    /**************************************************************************/
    static _yearDescriptionsContainer = null;
    static getYearDescriptionsContainer () { return this._yearDescriptionsContainer; }
    static setYearDescriptionsContainer (div) { this._yearDescriptionsContainer = div; }


    /**************************************************************************/
    /* The following is seriously unpleasant ...

       I have, in the :root section of the HTML file, some calc values which
       I need to use in the code here.  Unfortunately, calc values in a
       pure definition aren't resolved -- if you access them, you just get
       'calc(12 + 13)' or whatever.  The only way you can resolve them is
       actually to make HTML make use of them -- which means (with the
       numeric values I have here) setting numeric style properties to these
       values.  Once you have done that, you can then pick up the values
       you require from that tag.  In this case, the tag has id
       dummyRootResolver.

       One downside to this is that you have to give the values to things like
       margin-top etc, and it is not at all obvious that in order to pick up
       the value of --myValue, you need to access margin-top for the purpose.
       To ameliorate this slightly, I have added attributes to dummyRootResolver
       which associate the name you want to look up with the name of the
       property which has that value -- eg myValue='margin-top'.

       With all of that, the code here can then get at the values you want
       and can use meaningful names for the purpose.

       There is still one other issue, however.  The values I want here are
       used quite frequently, and I think they may be fairly expensive to
       obtain, so I cache them here.  Except that cached values are no good
       when, say, the user decides to change the font size.

       Fortunately, all of the values here are used in one place, while
       rendering the timeline, so 'all' you need do is make sure you call
       resetRootResolver before you first need to access them. */
    
    /**************************************************************************/
    static _dummyRootResolver = null;
    static _dummyRootResolverMap = null;
    static _initDummyRootResolver ()
    {
	if (null !== this._dummyRootResolver)
	    return;

	this._dummyRootResolver = document.getElementById('dummyRootResolver');
	this._dummyRootResolverMap = new Map();
	for (var attr of this._dummyRootResolver.attributes)
	    if (attr.name != 'id')
		this._dummyRootResolverMap.set(attr.name, getComputedStyle(this._dummyRootResolver)[attr.value]);
    }

    
    /**************************************************************************/
    static _getFromRootResolver (name)
    {
	this._initDummyRootResolver();
	return parseFloat(this._dummyRootResolverMap.get(name.toLowerCase()));
    }

    
    /**************************************************************************/
    static resetRootResolver () { this._dummyRootResolver = null; }

    
    /**************************************************************************/
    static getVerticalSpaceForDatesMinimumToAvoidOverlap () { return this._getFromRootResolver('verticalSpaceForDatesMinimumToAvoidOverlap'); }
    static getVerticalSpacePerYearForAmDates             () { return this._getFromRootResolver('verticalSpacePerYearForAmDates'); }
    static getVerticalSpacePerYearForNonAmDates          () { return this._getFromRootResolver('verticalSpacePerYearForNonAmDates'); }
}
