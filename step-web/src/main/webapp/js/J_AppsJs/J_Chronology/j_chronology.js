/******************************************************************************/
/* Displays chronology details.

   The details are shown on a vertical line, spaced in a 'reasonably' optimal
   manner (although this does mean that the user may have to scroll to see all
   of them).

   The caller should supply a div when calling init, and the chronology
   functionality is placed within that div.

   The data is generated by a Kotlin program 'FormatChronologyData', based upon
   data which is extracted manually from https://docs.google.com/spreadsheets/d/15WmvZ4C-6G62Cd9JuIvtcqGfJ_vEhi6YohSht4fmZZg/edit?gid=0#gid=0.

   See JChronologyData for more details.



   External access via URLs
   ========================

   showWelcome: If this appears as a URL parameter, it causes the welcome
     screen to be shown on entry.  In fact we may or may not allow for a
     welcome screen -- the jury is still out.  If used at all, I anticipate
     it will only be when coming from the Resources menu, and I will _probably_
     arrange for it to be shown only once.

   year=1000BC: This may be any date at all.  If the date corresponds to a
     particular event (or to the start of a duration, which is treated as
     though it were an event), that event is selected and made visible.
     If it does not have an associated event, things are positioned
     somewhere near the element.  The date should include one of AD, BC or
     AM (but no space).  I don't mind whether the letters are placed at the
     beginning or the end.  Dates are based upon the 'OtherDate' column of
     the chronology data.

   No year parameter: Acts as though year=3BC had been specified.  This
     corresponds to the nearest event to what would be AD 0 if such a
     date existed.



  External access via interframe communications
  =============================================

  At the time of writing, this relates purely to calls from the search frame,
  which is handled by a message containing a 'key' field.
*/
/******************************************************************************/

'use strict';

import { JFrameworkStepDataAccessors }                  from '/js/J_AppsJs/J_Framework/j_framework.stepDataAccessors.js';
import { ClassJFrameworkDraggable }                     from '/js/J_AppsJs/J_Framework/j_framework.draggable.js';
import { ClassJFrameworkModalDialog }                   from '/js/J_AppsJs/J_Framework/j_framework.modalDialog.js';
import { ClassJFrameworkMultiframeCommunicationsSlave } from '/js/J_AppsJs/J_Framework/j_framework.multiframeCommunicationsSlave.js';
import { JFrameworkSharedConstants }                    from '/js/J_AppsJs/J_Framework/j_framework.sharedConstants.js';
import { JFrameworkUserSettings }                       from '/js/J_AppsJs/J_Framework/j_framework.userSettings.js';
import { JFrameworkUtils }                              from '/js/J_AppsJs/J_Framework/j_framework.utils.js';
import { JChronologyDataUrl }                           from '/js/J_AppsJs/J_Chronology/j_chronologySharedCode.js';
import { JFrameworkChapterSummaries }                   from '/js/J_AppsJs/J_Framework/j_framework.chapterSummaries.js';

export const ModalDialogHandler = new ClassJFrameworkModalDialog();
window.ModalDialogHandler = ModalDialogHandler;





/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                                   Main                                   **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
class _ClassJChronology extends ClassJFrameworkMultiframeCommunicationsSlave
{
    /**************************************************************************/
    /* We need to obtain the data and then run the bulk of the processing.  To
       that end, I have to pass something which does the bulk processing as an
       argument to the read method. */

    onload (container)
    {
	this._container = container;

	JFrameworkSharedConstants.setHrefs();
	
	JChronologyDataCommon.loadData(this._onload.bind(this)); // Get the data.
	
	ModalDialogHandler.addModalCloseButtonHandlers(); // Add close handlers to everything which has a close button.
	
	ClassJFrameworkDraggable.initialise(); // Make any appropriate pop-ups draggable.



	/**********************************************************************/
	/* The chronology display comprises two columns.  Only the right one
	   has a vertical scroll bar, but I need to arrange that if the user
	   scrolls, both are affected. */
	
	const leftCol = document.getElementById('jchronologyTimeline');
	const rightCol = document.getElementById('jchronologyYearDescriptions');

	rightCol.addEventListener('scroll', () => {
	    leftCol.scrollTop = rightCol.scrollTop;
	});
    }


    /*************************************************************************/
    /* Receives inter-iframe messages and processes them. */

    receiveMessage (data, callingFrameId)
    {
	_JChronologyPresentationHandler.selectEvent(this._getDivGivenKey(data.key));
    }

    
    /**************************************************************************/
    resize ()
    {
	JChronology._adjustPositionOfLine();
	JChronology._checkDurationOverlaps();
	this._respondToFrameWidthChanges();
    }

    
    /*************************************************************************/
    /* Returns the div which matches a given key. */
    
    _getDivGivenKey (key)
    {
	return this._eventDateAndMarkerDivGivenKey.get(key);
    }

    
    /**************************************************************************/
    /* The URL for the present page may be 'revised' (including set up for the
       first time) either because of a direct intervention from the 3-panel
       page, or because the people index pane has been used to select a new
       person.

       The former occurs where the 3-panel has been invoked from the sidebar
       as a result of someone looking up Strong's information while reading
       scripture.  The latter (ie when invoked from the people index) occurs
       when already in 3-pane mode, and selecting a new person.

       There is also the possibility that the present code may be called with
       no selection at all, in which case I have been asked to default to
       Aaron. */
  
    _makeInitialSelection ()
    {
	/**********************************************************************/
	const urlParms = new URLSearchParams(new URL(window.location.href).search);
	var year = urlParms.get('year') ?? '3BC'; // Nearest date to 1AD which actually has a corresponding event.
	var showWelcome = urlParms.has('showWelcome');
	var type = urlParms.get('type') ?? 'event';



	/**********************************************************************/
	const selection = JChronologyData.findBracketingEntries(year, type);
	if (null === selection.match)
	{
	    const yearOffset = JFrameworkUtils.convertToYearOffset(year);
	    const pos = yearOffset < this._lastOffsetYearInAm ? this._rawPositionFunctionForAmDates(this, yearOffset) : this._rawPositionFunctionForNonAmDates(this, yearOffset);
	    _JChronologyPresentationHandler.selectNonEvent(pos);
	}	    
	else
	{
	    const key = JChronologyData.getKey(selection.match);
	    const matchingDiv = this._eventDateAndMarkerDivGivenKey.get(key);
	    _JChronologyPresentationHandler.selectEvent(matchingDiv);
	}



	/**********************************************************************/
	if (showWelcome)
	{
	    if (null == localStorage.getItem('JChronologyHaveShownWelcome'))
	    {
		localStorage.setItem('JChronologyHaveShownWelcome', 'Yes');
		ControlsHandler.showWelcome();
	    }
	}
    }


    /**************************************************************************/
    /* Carries out initialisation once all of the data has been loaded. */
    
    _onload ()
    {
	/**********************************************************************/
	/* Determine the width of the frame, so that things are initialised to
	   have the correct visibility. */
	
	this._updateFrameWidth();


	
	/**********************************************************************/
	/* Some of the fields are supplied in at most partly finished form.
	   These need to be updated to take into account how we actually want
	   to process them. */
	
	JChronologyData.index();
	JChronologyData.reformatData();


	
	/**********************************************************************/
	/* Creates various bits and pieces needed in the graphical part of the
	   display, works out how things need to be spaced, and then positions
	   them. */
	
	this._createBasicElements(this._container);
	this._render();



	/**********************************************************************/
	/* Event callbacks. */

	window.addEventListener('load',   this.resize.bind(this));
	window.addEventListener('resize', this.resize.bind(this));
	if (document.fonts && document.fonts.ready)
	    document.fonts.ready.then(this.resize.bind(this));



	/**********************************************************************/
	/* Throttle to improve performance when scrolling the thing which
	   contains the duration lines. */
	
	const me = this;
	const container = 'R' == _ClassJChronologyUtilities.C_DurationsColumn ? _ClassImportantElements.getYearDescriptionsContainer() : _ClassImportantElements.getTimelineContainer();
	var durationScrollTimeout = null;
	container.addEventListener("scroll", () => {
	    if (durationScrollTimeout) return;
	    durationScrollTimeout = requestAnimationFrame(() => {
		me._checkDurationOverlaps();
		durationScrollTimeout = null;
	    });
	});




	/**********************************************************************/
	/* Arrange to respond to changes the user makes to the setting --
	   colours, font sizes, etc. */
	
	function fnUserSettingsChanged (firstTime)
	{
	    const background = getComputedStyle(document.documentElement).getPropertyValue("--clrBackground").trim();
	    const isDark = JFrameworkUtils.isDark(background);
	}
	JFrameworkUserSettings.init(fnUserSettingsChanged);



	/**********************************************************************/
	this._makeInitialSelection();
    }

	
    /**************************************************************************/
    /* I _think_ we want things left-aligned as far as possible, so as to give
       plenty of room for the description of the events.  This determines the
       maximum width required to contain the date labels, and then shifts
       everything to the left accordingly. */
    
    _adjustPositionOfLine ()
    {
	/**********************************************************************/
	var maxDateWidth = 0;
	const dates = document.querySelectorAll('.jchronologyEventDate');
	dates.forEach(date => {
	    maxDateWidth = Math.max(maxDateWidth, date.offsetWidth);
	});



	/**********************************************************************/
	/* Adjust the markers to be centred on the timeline. */
	
	const markers = document.querySelectorAll('.jchronologyEventMarker');
	const markerStyle = window.getComputedStyle(markers[0]);
	const markerHalfWidth = parseFloat(markerStyle.width) / 2;
	const markerMargin = 2 * parseFloat(markerStyle.borderLeftWidth); // Not exactly sure why we need '2 *', but apparently we do.
	const markerLeft = (markerMargin - markerHalfWidth) + 'px';
	markers.forEach(marker => {
	    marker.style.left = markerLeft;
	});



	/**********************************************************************/
	/* Move the line. */

	this._linePosition = maxDateWidth + 20;
	const line = _ClassImportantElements.getTimeline();
	const allowanceForDurationLines = _ClassJChronologyUtilities.getDurationLineWidth() * _ClassJChronologyUtilities.C_DurationColours.length;
	line.style.left = `${this._linePosition}px`;
	document.documentElement.style.setProperty('--mainChronologyLineCentre', this._linePosition + 'px');

	const extraSpace = 'R' == _ClassJChronologyUtilities.C_DurationsColumn ? parseFloat(getComputedStyle(line).width) + markerHalfWidth : allowanceForDurationLines + parseFloat(getComputedStyle(line).width);
	document.documentElement.style.setProperty('--chronologyTimelineWidth',  (9 + this._linePosition + extraSpace) + 'px'); // Leave space at right to hold durations etc.




	/**********************************************************************/
	/* Make the width of the button overlay the same as the offset of the
	   timeline.  This then makes it possible to position the date help
	   button centrally over the dates. */
	
	_ClassImportantElements.getDurationHeadersButtonOverlay().style.width = line.style.left



	/**********************************************************************/
	/* Move the dates. */
	
	dates.forEach(date => {
	    date.style.left = -(date.offsetWidth + 16) + 'px'; // 16px gap between right of date and line.
	});



	/**********************************************************************/
	/* Move the descriptive information. */
	
	const details = document.querySelectorAll('.jchronologyEventDescription');
	details.forEach(detail => {
	    detail.style.left = '10px';
	});
    }


    /**************************************************************************/
    /* We need to check when duration bars overlap the top of the graphics
       area so as to be able to update the div which tells the user about
       them. */
    
    _checkDurationOverlaps ()
    {
	/**********************************************************************/
	/* Does the header for a single item. */
	
	const durationHeaderContainer = _ClassImportantElements.getDurationHeaderContainer();
	const timeline = _ClassImportantElements.getTimeline();
	const linePosition = this._linePosition;
	var nDisplayableEntries = -1;
	
	function renderHeaderForItem (durationLineDiv)
	{
	    const entry = JChronologyData.getEntryGivenElement(durationLineDiv);
	    const channelNo = JChronologyData.getDurStartChannelNo(entry);
	    const line = document.createElement('div');
	    line.className = 'jchronologyDurationHeaderLine';

	    line.style.left = (2 + parseFloat(durationLineDiv.style.left)) + 'px'; // '+2' allows for left margin of some containers.
	    line.style.height = (1 + (1.5 * --nDisplayableEntries)) + 'em';

	    const label = document.createElement('div');
	    label.className = 'jchronologyDurationHeaderLabel';
	    label.textContent = JChronologyData.getYearDescription(entry);

	    var colour = getComputedStyle(durationLineDiv).backgroundColor;
	    line.style.borderLeftColor = colour;
	    label.style.color = colour;

	    line.appendChild(label);
	    durationHeaderContainer.appendChild(line);
	}
	


	/**********************************************************************/
	/* We need to remove any existing lines and labels, but we need to
	   retain the overlay at the left which I use to hold the help
	   button. */
	
	const container = 'R' == _ClassJChronologyUtilities.C_DurationsColumn ? _ClassImportantElements.getYearDescriptionsContainer() : _ClassImportantElements.getTimelineContainer();
	const containerTop = container.getBoundingClientRect().top;

	Array.from(durationHeaderContainer.children).forEach(child => {
	    if (child.id !== 'jchronologyDurationHeadersButtonOverlay' && child.id !== 'jchronologyMenuButtonOverlay')
		child.remove();
	});



	/**********************************************************************/
	/* Find out which items, if any, need to be displayed. */
	
	const reports = [];
	this._durationLines.forEach(item => {
	    const rect = item.getBoundingClientRect();
	    const doReport = rect.top <= containerTop && rect.bottom > containerTop;
	    if (doReport)
		reports.push(item);
	});




	/**********************************************************************/
	/* Order elements by channel no. */

	function orderFn (durationLineDiv)
	{
	    const entry = JChronologyData.getEntryGivenElement(durationLineDiv);
	    return JChronologyData.getDurStartChannelNo(entry);
	}


	
	/**********************************************************************/
	nDisplayableEntries = reports.length;
	reports.sort((a, b) => orderFn(a) - orderFn(b));
	reports.forEach(item => {
	    renderHeaderForItem(item);
	});
    }


    
    /**************************************************************************/
    _clearGraphics ()
    {
	document.getElementById('jchronologyTimelineLine').remove();
	this._createBasicElements();
	document.querySelectorAll('.jchronologyDurationLine').forEach(el => el.remove());
    }
	
    

    /**************************************************************************/
    /* Courtesy of ChatGPT.  This is used when displaying, on the timeline,
       details of the chapters which refer to events in a given year.  We often
       have several consecutive chapters, and rather than display each
       individually, I convert them to ranges. */
    
    _convertToRanges (input)
    {
	// Split the input string into chunks
	const chunks = input.split("; ").map(s => s.trim()).filter(Boolean);

	// Parse into { prefix, num }
	const items = chunks.map(s => {
	    const [prefix, numStr] = s.split(".");
	    return { prefix, num: parseInt(numStr, 10) };
	});

	const result = [];
	let start = items[0];
	let last = items[0];

	for (let i = 1; i <= items.length; i++)
	{
	    const curr = items[i];
	    if (curr   &&   curr.prefix === last.prefix   &&   curr.num === last.num + 1)
		last = curr; // Still in the same sequential run.
	    else
	    {
		// End of current run
		if (start.num === last.num)
		    result.push(`${start.prefix}.${start.num}`);
		else
		    result.push(`${start.prefix}.${start.num}-${last.num}`);
		
		start = curr;
		last = curr;
	    }
	}

	return result.join("; ");		
    }

	    
    /**************************************************************************/
    /* Creates a div to hold everything, and a div to represent the timeline,
       and adds them to the overall container supplied by the caller. */
    
    _createBasicElements (container)
    {
	const div = document.createElement('div');
	div.id = 'jchronologyTimelineLine';
	_ClassImportantElements.setTimeline(div);

	_ClassImportantElements.getTimelineContainer().appendChild(div);

	return div;
    }

    
    /**************************************************************************/
    _render ()
    {
	this._clearGraphics();
	
	const durationDetails = this._renderTimeline(); // Maps start keys to the start/end divs which will demarcate the duration line.

	const durationDetailsByOffsetYear = new Map();
	for (const key of durationDetails.keys())
	{
	    const startAndEndDiv = durationDetails.get(key);
	    const entry = JChronologyData.getEntryGivenElement(startAndEndDiv[0]);
	    const yearOffset = JChronologyData.getYearOffset(entry);

	    if (!durationDetailsByOffsetYear.has(yearOffset)) // Note that while no two _events_ share the same date, more than one duration can have the same start date, so we need a multimap here.
		durationDetailsByOffsetYear.set(yearOffset, []);
	    durationDetailsByOffsetYear.get(yearOffset).push(startAndEndDiv);
	}

	const sortedYearOffsets = [...durationDetailsByOffsetYear.keys()].sort((a, b) => a - b);
	for (const yearOffset of sortedYearOffsets)
	{
	    const startAndEndDivs = durationDetailsByOffsetYear.get(yearOffset);
	    startAndEndDivs.forEach( (item, index) => { this._renderDuration(item); });
	}
	
	this._checkDurationOverlaps();

	_JChronologyPresentationHandler.reselectEventOrNonEvent();
    }


    /**************************************************************************/
    /* There are some benefits to having these in the right hand column.
       However, if we want the durations to remain visible even when scrolling
       the right-hand column horizontally, it'll have to be the left. */
    
    _durationLines = [];
    _renderDuration (startAndEnd)
    {
	/**********************************************************************/
	/* Data from chronology database. */
	
	const dataEntry = JChronologyData.getEntryGivenElement(startAndEnd[0]);
	const colour = JChronologyData.getDurStartColour(dataEntry);
	const channelNo = JChronologyData.getDurStartChannelNo(dataEntry);
	const isRegency = JChronologyData.getDurStartIsRegency(dataEntry);



	/**********************************************************************/
	/* Relatively fixed information. */
	
	const C_PutInRightColumn = 'R' == _ClassJChronologyUtilities.C_DurationsColumn;
	const verticalStartPos = parseFloat(startAndEnd[0].style.top);
	const verticalEndPos   = parseFloat(startAndEnd[1].style.top);



	/**********************************************************************/
	/* Create and position the div which will represent this duration. */
	
	const newLine = document.createElement('div'); this._durationLines.push(newLine);
	(C_PutInRightColumn ? _ClassImportantElements.getYearDescriptionsContainer() : _ClassImportantElements.getTimelineContainer()).appendChild(newLine);
	newLine.classList.add('jchronologyDurationLine');
	newLine.style.left = _ClassJChronologyUtilities.getChannelLeft(_ClassImportantElements.getTimeline(), channelNo) + 'px';
	newLine.style.background = colour;
	newLine.style.height = (verticalEndPos - verticalStartPos - 5) + 'px'; // The -5 gives some space at the bottom of each line, so that if one line ends and another starts at the same date, we can see a break between the two.
	newLine.style.top = `${verticalStartPos}px`;
	newLine.setAttribute('data-key', startAndEnd[0].getAttribute('data-key'));

	if (isRegency)
	    newLine.classList.add('regency');
//	    newLine.style.background = `repeating-linear-gradient(to bottom, ${colour} 0 10px, yellow 10px 20px)`;

	if (_ClassJChronologyUtilities.C_Dbg)
	{
	    const info = `Key: ${key}  Col: ${channelNo}  Top: ${verticalStartPos}  Bottom: ${verticalEndPos} Date: ${JChronologyData.getEventDateLabel(dataEntry)}`;
	    console.log(info);
	    newLine.addEventListener('click', function (event) {
		alert(info);
	    });
	}
    }

    
    /**************************************************************************/
    /* The layout comprises two divs, side by side.

       The left-hand div contains, for each event, the date label and the
       circle marker.  The vertical line which represents the timeline also
       goes here.

       The right-hand div contains the description of each event.

       The reason for splitting things this way is that I want to be able to
       have the description scroll horizontally if necessary, but I want the
       date details to remain fixed horizontally.

       This brings with it a complication, because I want just a single
       vertical scroll bar down the right of the right-hand div, but I have
       to arrange for this to scroll both divs at the same time.

       The 'events' which appear here come in two -- or perhaps three --
       groups.

       There are the plain vanilla events -- the things the user actually
       needs to be aware of.  The available data for each event includes a
       'year offset' which says how far from year 0 this event occurs.
       This gives me a first stab at positioning each event -- I just need
       to map this proportionately to a vertical position within the div.
       However, this may not, of itself, be sufficient: events which occur
       close together may end up so close on the screen that their details
       overlap.  So having determined this first tentative position, I may
       then have to move the new event down to clear any existing text.
       This does mean that the proportional spacing on close-together events
       may go awry, but I can't presently see a better option.

       So much for plain vanilla events.  We also need to cope with
       durations.  Each duration appears in the data as a start event
       and an end event, each carrying the relevant year offset.

       It is convenient to include these on the timeline in more or less
       the same way as ordinary events, and to base the duration lines on
       the positions of these pseudo events, because then whatever mechanism
       I come up with to cope with resizing etc should work for both.

       However, I did say 'more or less'.  Duration-related events don't want
       to be visible to the user, nor (unlike 'real' events) do they want to
       be clickable.  I cater for this by placing them below real events in
       the z-order, by hiding them, and by not adding click handlers.  In
       addition, because they don't need to be visible, there is no problem
       in them overlapping real events.
    */
    
    // All of these _were_ internal to _renderTimeline, and I'd have preferred to keep them that way, but I need to be able to use the rawPosition functions in _makeInitialSelection.
    _headerAndTrailerHeight = 20;
    _lastOffsetYearInAm = -1;
    _lastPosInAm = -1;
    _rawPositionFunctionForAmDates    (me, yearOffset) { return me._headerAndTrailerHeight + yearOffset * (15 / 10); } // 15px to represent 10 years.
    _rawPositionFunctionForNonAmDates (me, yearOffset) { return me._lastPosInAm + (yearOffset - me._lastOffsetYearInAm) * (150 / 10); } // 150px to represent 10 years.

    _eventDateAndMarkerDivGivenKey = new Map();
    _renderTimeline ()
    {
	/**********************************************************************/
	this._eventDateAndMarkerDivGivenKey.length = 0;


	
	/**********************************************************************/
	/* The AM events and the BC / AD events are subject to different
	   spacing regimes, so it's convenient to split them into two separate
	   lists. */
	
	function isAmEvent (event) { return JChronologyData.getYearOffset(event) <= _ClassJChronologyUtilities.C_LastAmDate; }

	const events = JChronologyData.getEntries();

	const [amEvents, bcAdEvents] = 
	      events.reduce(
		  ([pass, fail], elem) => {
		      return isAmEvent(elem)
			  ? [[...pass, elem], fail]
			  : [pass, [...fail, elem]];
		  },
		  [[], []]
	      );
    

	
	/**********************************************************************/
	const C_FontSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--defaultfont').trim());
	const C_GapBetweenLines = 10;
	var mostRecentOffsetYear = -1;
	var mostRecentPos = -1;
	const durationMap = new Map();
	var rawPositionFunction = null;



	/**********************************************************************/
//	var dbgPrevEventDetails = ['???', 9999, 9999];


	
	/**********************************************************************/
        const doEvent = (e, type) =>
	{
	    /******************************************************************/
	    const isEvent = JChronologyData.isEvent(e);
	    const isChapterEvent = JChronologyData.isChapterEvent(e); // A pseudo event assocated with the start of a chapter.
	    const flags = isEvent ? JChronologyData.getEventFlags(e) : ''; // Tells us whether this is an approximate date, etc.
	    const key = JChronologyData.getKey(e);



	    /******************************************************************/
	    /* Work out where to put the tag ...

	       If this is a plain vanilla event tag, try positioning it as
	       would be dictated by the date of the event within the overall
	       chronology.  If that would overlap with the most recent event
	       tag, move it down a bit.  And either way, record the position
	       so that we can check for overlaps next time round.  We also
	       record the year offset for use with duration processing. */

	    var pos = -1;
	    
	    if (isEvent)
	    {
		mostRecentOffsetYear = JChronologyData.getYearOffset(e);
		pos = rawPositionFunction(this, mostRecentOffsetYear);
		pos = Math.max(pos, mostRecentPos + C_FontSize + C_GapBetweenLines);

//		console.log(JChronologyData.getEventDateLabel(e) + ' / ' + dbgPrevEventDetails[0] + '     ' + (JChronologyData.getYearOffset(e) - dbgPrevEventDetails[1]) + '     ' + (pos - mostRecentPos));
//		dbgPrevEventDetails = [JChronologyData.getEventDateLabel(e), JChronologyData.getYearOffset(e), pos];

		mostRecentPos = pos;
	    }



	    /******************************************************************/
	    /* Duration tags are different.  I do create them, because they
	       are useful to make the start and end of duration lines, such
	       that the positions can be readily updated with screen
	       resizing etc.  But they are invisible, and there is therefore
	       no problem if they overlap things -- and also the presence
	       of a duration tag does not get in the way of event tags.

	       So to get the easy bit out of the way first ... we _do_
	       need to work out a position, but we don't need to update
	       mostRecentOffsetYear or mostRecentPos, because what we are
	       doing here is essentially invisible to the processing for
	       'real' events.

	       As regards the position, because the chronology data is
	       ordered by offset year, and further ordered so that if a
	       duration event shares the same date as a real event, the
	       duration event always comes later in the ordering, we can
	       simply take the larger of the position given by the raw
	       chronology-based calculation and the most recent event
	       position. */

	    else // A duration tag.
	    {
		const offsetYear = JChronologyData.getYearOffset(e);
		pos = Math.max(rawPositionFunction(this, offsetYear), mostRecentPos);
		pos += C_FontSize / 2;
	    }



	    /******************************************************************/
	    /* This next block of code is basically common for event tags
	       and duration tags.  The only difference is that I don't add
	       click handlers to duration events, because they are a behind-
	       the-scenes artefact, which I want the user to be unaware of.

	       The date label and the marker circle go in eventDateAndMarkerDiv,
	       which we use for positioning and click handler. */
	    
	    const eventDateAndMarkerDiv = document.createElement('div');
	    eventDateAndMarkerDiv.className = 'jchronologyEventDateAndMarkerHolder';
	    eventDateAndMarkerDiv.style.top = pos + 'px';
	    if (isEvent) eventDateAndMarkerDiv.addEventListener('click', () => ClickHandlers.eventClickHandler(eventDateAndMarkerDiv));
	    eventDateAndMarkerDiv.setAttribute('data-key', key);
	    this._eventDateAndMarkerDivGivenKey.set(key, eventDateAndMarkerDiv);

	    const dateDiv = document.createElement('div');
            dateDiv.classList.add('jchronologyEventDate');

	    if (flags.includes('~'))
		dateDiv.classList.add('jchronologyDateApproximate');
	    else
		dateDiv.classList.add('jchronologyDateDefinite');
		
	    // if (flags.includes('*')) dateDiv.classList.add('jchronologyDateDisputedOrdering'); Commented out: David has suggested not marking these.

	    if (isChapterEvent)
		dateDiv.innerHTML = JChronologyData.getEventDateLabel(e);
	    else if (isEvent)
		dateDiv.innerHTML = isEvent? '<span class="spanShowOnWideScreenOnly">' + JChronologyData.getEventUssherDate(e) + ' &bull; </span>' +JChronologyData.getEventDateLabel(e) : '';
	    else
		dateDiv.innerHTML = '';
	    
	    eventDateAndMarkerDiv.appendChild(dateDiv);

	    const circle = document.createElement('div');
	    circle.className = 'jchronologyEventMarker';
	    eventDateAndMarkerDiv.appendChild(circle);

	    _ClassImportantElements.getTimeline().appendChild(eventDateAndMarkerDiv);



	    /******************************************************************/
	    /* The eventDateAndMarkerDiv has to go in the div which makes up
	       the left hand column of the chronology display.  The description
	       goes in the right hand column.  To keep the overall structure
	       roughly the same as for the left hand column, it's convenient
	       to create eventDescriptionContainerDiv, analogous to
	       eventDateAndMarkerDiv, for positioning and click handler. */
	    
	    const eventDescriptionContainerDiv = document.createElement('div');
	    eventDescriptionContainerDiv.className = 'jchronologyEventDescriptionHolder';
	    eventDescriptionContainerDiv.style.top = pos + 'px';
	    if (isEvent) eventDescriptionContainerDiv.addEventListener('click', () => ClickHandlers.eventClickHandler(eventDescriptionContainerDiv));
	    eventDescriptionContainerDiv.setAttribute('data-key', key);
	
	    const descriptionDiv = document.createElement('div');
	    descriptionDiv.className = 'jchronologyEventDescription';
	    if (isChapterEvent) descriptionDiv.classList.add('jchronologyChapterEventDescription');

	    const rawContent = _ClassJChronologyUtilities.withoutLinks(JChronologyData.getYearDescription(e));
	    var content = isChapterEvent ? '&#x1F56E;&nbsp;' + this._convertToRanges(rawContent) : rawContent;
	    
	    if (isEvent) descriptionDiv.insertAdjacentHTML('beforeend', _ClassJChronologyUtilities.withDurationColours(content));
	    eventDescriptionContainerDiv.appendChild(descriptionDiv);
	    _ClassImportantElements.getYearDescriptionsContainer().appendChild(eventDescriptionContainerDiv);
	    
	    circle.style.top = ((parseFloat(getComputedStyle(descriptionDiv).height) - parseFloat(getComputedStyle(circle).height)) / 2) + 'px'; // Centre vertically.

	    JChronologyData.recordMarker(key, circle);



	    /******************************************************************/
	    if (!isEvent)
	    {
		eventDateAndMarkerDiv.classList.add('jchronologyDurationElement');
		dateDiv.classList.add('jchronologyDurationElement');
		circle.classList.add('jchronologyDurationElement');
		eventDescriptionContainerDiv.classList.add('jchronologyDurationElement');
		descriptionDiv.classList.add('jchronologyDurationElement');

		if (JChronologyData.isDurStart(e))
		    durationMap.set(JChronologyData.getKey(e), eventDateAndMarkerDiv) // Temporarily this maps the key of the duration-start to the hidden div which marks the start.
		else
		{
		    const key = JChronologyData.convertDurationEndKeyToStartKey(JChronologyData.getKey(e));
		    const start = durationMap.get(key);
		    durationMap.set(key, [start, eventDateAndMarkerDiv]); // This now replaces the temporary entry with one which maps the key of the duration-start to the pair of hidden divs which mark the start and end.
		}
	    }
	}


	
	/**********************************************************************/
	/* Deal first with the 'AM' events.  The raw position of these is
	   reasonably easy, because AM simply runs forward from 0, so the
	   position is determined by leaving a bit of a gap for the header,
	   and then just converting the offset year proportionately to a
	   number of pixels.  (This initial raw position may then be adjsted
	   to avoid overlaps.) */
	
	rawPositionFunction = this._rawPositionFunctionForAmDates;
	for (const e of amEvents)
	    doEvent(e, 'AM')



	/**********************************************************************/
	/* This makes it possible to have a different spacing for BC events,
	   on the grounds that in the main they are rather closer together.
	   Whether this helps is, perhaps, dubious.  If you make them far
	   enough apart to reduce the number of overlaps (and therefore to
	   make the spacing more proportionate), you end up with some huge
	   gaps. */

	this._lastPosInAm = mostRecentPos;
	this._lastOffsetYearInAm = mostRecentOffsetYear;
	rawPositionFunction = this._rawPositionFunctionForNonAmDates;
	for (const e of bcAdEvents)
	    doEvent(e, 'BCAD')
	
	

	/**********************************************************************/
	/* Add a pseudo marker which can be used when invoked with a date which
	   doesn't feature in the list of events. */
	
	const circle = document.createElement('div');
	circle.classList.add('jchronologyEventMarker', 'jchronologyEventMarkerHighlight');
	circle.style.display = 'none';
	_ClassImportantElements.setArbitraryDateMarker(circle);
	_ClassImportantElements.getTimeline().appendChild(circle);
	_JChronologyPresentationHandler.reselectNonEvent();



	/**********************************************************************/
	_ClassImportantElements.getTimeline().style.height = (mostRecentPos + 2 * this._headerAndTrailerHeight) + 'px';
	this._adjustPositionOfLine();
	return durationMap;
    }


    /**************************************************************************/
    _respondToFrameWidthChanges ()
    {
	if (this._updateFrameWidth())
	    this._render();
    }


    /**************************************************************************/
    /* Determines if the screen changes have resulted in the chronology frame
       going from 'wide' to 'narrow' or vice versa (sizes defined here).  If
       so, changes class settings in the body to deal with things whose
       visibilty has to depend upon frame width. */
    
    _updateFrameWidth ()
    {
	const containerWidth = parseFloat(window.getComputedStyle(_ClassImportantElements.getChronologyContainer()).width);
	if (containerWidth > 500)
	{
	    if (document.body.classList.contains('isWideScreen')) return false;
	    document.body.classList.remove('isNarrowScreen');
	    document.body.classList.add('isWideScreen');
	}
	else
	{
	    if (document.body.classList.contains('isNarrowScreen')) return false;
	    document.body.classList.add('isNarrowScreen');
	    document.body.classList.remove('isWideScreen');
	}

	return true;    }
}

export const JChronology = new _ClassJChronology();





/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                                Data common                               **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
class _ClassJChronologyDataCommon
{
    /**************************************************************************/
    loadData (afterLoadFn)
    {
	Promise.all([this._load(JChronologyData)])
	    .then(([events]) => { afterLoadFn(); })
	    .catch(error => {
		console.error(`Error loading files: ${error.stack}`);
	    });
    }


    /**************************************************************************/
    _load (dataClass)
    {
	return fetch(dataClass.dataUrl())
	    .then(response => {
		if (!response.ok) {
		    throw new Error(`Failed to fetch: ${response.status}`);
		}
		return response.text();
	    })

	    .then(text => { // Success.
		const lines = text.split(/\r?\n/);
		if (lines[lines.length - 1].trim() === "") // A newline at the end of the file means the processing sees a blank line, which we do not want.
		    lines.pop();

		dataClass._data = lines.map(line => {
		    return line.split('\t', 99);
		})

		return;
	    })
	
	    .catch(err => {
		console.error('Error in _load', err);
		//throw err; // rethrow if you want the caller to handle it too
	    });
    }
}

const JChronologyDataCommon = new _ClassJChronologyDataCommon();





/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                                   Data                                   **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/* The data comprises three different kinds of records:

   - Details of individual events.
   - Duration-start records.
   - Duration-end records.


   It is in tab-separated form, and all records have the same number of
   fields, although not all of those fields are used in all of the different
   flavours of record, and the fields are put to different uses in each
   (although there are a few things which are common to the different
   records, and I've put common things in common fields).

   Individual events are just what they sound like.

   Durations cover a period of time, and therefore come as a start and end
   record.

   The data contains all of these, chronologically ordered (the order
   being determined by the 'OtherDate' field in the raw data.

   There is never more than a single event with a given date: if several
   things of interest all occurred in the same year, there is a single
   event entry for that year, with a description which mentions all of the
   things which happened.

   By contrast there may be several duration records for a given year --
   several durations may start in a given year, several may end in a given
   year, and also some may end and some may start in a given year.  And in
   addition, a number of duration records may share the same year as a
   pukka event.

   Where several duration records share the same year, there is no
   guarantee as to the ordering amongst them.  But if duration records
   share a year with an event record, the duration records are guaranteed
   to come out _after_ the event record.

   Duration records are not displayed to the user -- they simply mark the
   start and end of the duration lines which show, for instance, the
   lifespan of a given individual.

   It might be felt that mixing durations and events was a complication,
   and possibly in some respects it is.  However, it does bring with it
   a significant advantage, in that the code which amends the layout in
   response to (for instance) user decisions to change the font size
   will automatically also cover the changes which have to be made to
   the duration lines.

   Each record has an associated 'offset year'.  This enables you to position
   records on the display.  The very first event has an offset of zero, and all
   other records have values running forward from that.  This masks the
   difference between the various epoch schemes (AM, BC and AD).  It is this
   offset year which determines the order of the incoming records.

   Each record also has a unique key field.  The keys for event records start
   with 'E', and those for duration starts and ends start with 'Ds' and 'De'
   repsectively.

   The data is supplied in tab-separated variable form, and split out here.
   For details of the fields in each kind of record, see the definitions at the
   top of the code below.

   DateLabel is of the form:

    <JChronDate approx='y' disputedOrder='y'> ... </JChronDate>

  where both, either, or none of the attributes may be present, and should
  give rise to appropriate formatting to reflect the kind of doubt.

  
  All of YearDescription, AiArticle and OtherAiData may contain

    <jLink data-type='P or L' data-strong='G1234' clickHandler>Fred</jLink>
    <jLink data-type='S'      data-ref='Gen.1.2-Gen.1.5' clickHandler>Gen.1.2-5</jLink>


  where the 'P' or 'L' indicates that this is a person or a location.  These
  are to serve as links to maps or genealogy data (both to be loaded in a
  new browser tab).  xChronClick needs to be replaced by appropriate code
  to achieve this.

  The 'S' version makes it possible to update the scripture window instead.

  Note that each of these fields may be used in more than one place (on
  the timeline, in the search data, in the info-box), and it may be that
  in one or more of these locations we do not want the jLink tags
  to act as a link.
*/

class _ClassJChronologyData
{
    /**************************************************************************/
    dataUrl () { return JFrameworkUtils.getFullUrl(JChronologyDataUrl); }


    /**************************************************************************/
    getEntries () { return this._data; }
    getEntryGivenElement (elt) { return this._keyMap.get(elt.getAttribute('data-key')); }
    getEntryGivenIndex (ix){ return this._data[ix]; }
    getNumberOfEntries () { return this._data.length; }



    _Ix_DurStart_Key              = 0; // 'Ds0000', 'Ds0001', etc.
    _Ix_DurStart_YearOffset       = 1; // Year-offset for start of duration.
    _Ix_DurStart_ChannelNo        = 2; // Says where to draw the duration line on the screen.  Zero says at the left, one, says a bit further to the right, etc.
    _Ix_DurStart_Colour           = 3; // Used to determine the colour to be used for the line.
    _Ix_DurStart_YearDescription  = 4; // Description of the duration -- someone's lifespan, for instance.
    _Ix_DurStart_Type             = 5; // 'Sovereign', 'Regent', ...



    _Ix_DurEnd_Key                = 0; // 'De0000', 'De0001', etc.
    _Ix_DurEnd_YearOffset         = 1; // Year-offset for start of duration.


    
    _Ix_Event_Key                 = 0; // 'E0000', 'E0001', etc.
    _Ix_Event_YearOffset          = 1; // Year-offset for the event.
    _Ix_Event_UssherDate          = 2; // What it says on the tin.
    _Ix_Event_DateLabel           = 3; // Text giving the date of the event. AKA OtherDate in the raw data.
    _Ix_Event_YearDescription     = 4; // Brief description of event used on timeline.
    _Ix_Event_Flags               = 5; // Empty, or some combination of '~' (indicating the date is approximate) or '*' (indicating different chronologies use different orderings here).
    _Ix_Event_ScriptureRefs       = 6; // Any relevant references.
    _Ix_Event_ExtraRefs           = 7; // Extra-biblical references.
    _Ix_Event_AiArticle           = 8; // Longer description.
    _Ix_Event_AdditionalFields    = 9; // Possibly lots of additional descriptions; possibly none.

    getKey                      (entry) { return entry[this._Ix_DurStart_Key];  }               // Common.
    getYearOffset               (entry) { return Number(entry[this._Ix_DurStart_YearOffset]); } // Common.
    getYearDescription          (entry) { return entry[this._Ix_DurStart_YearDescription]; }    // Common -- always an empty string for DurEnd, and not relevant.
    
    getDurStartYearOffset       (entry) { return this.getYearOffset(entry); }
    getDurStartYearDescription  (entry) { return this.getYearDescription(entry); }
    getDurStartChannelNo        (entry) { return Number(entry[this._Ix_DurStart_ChannelNo]); }
    getDurStartColour           (entry) { return entry[this._Ix_DurStart_Colour]; }
    getDurStartIsRegency        (entry) { return entry[this._Ix_DurStart_Type].startsWith('R'); }

    getDurEndDateLabel          (entry) { return ''; }
    getDurEndYearDescription    (entry) { return ''; }
    getDurEndYearOffset         (entry) { return this.getYearOffset(entry); }

    getEventYearOffset          (entry) { return this.getYearOffset(entry); }
    getEventDateLabel           (entry) { return entry[this._Ix_Event_DateLabel]; }
    getEventYearDescription     (entry) { return this.getYearDescription(entry); }
    getEventFlags               (entry) { return entry[this._Ix_Event_Flags]; }
    getEventUssherDate          (entry) { return entry[this._Ix_Event_UssherDate]; }
    getEventScriptureRefs       (entry) { return entry[this._Ix_Event_ScriptureRefs]; }
    getEventExtraRefs           (entry) { return entry[this._Ix_Event_ExtraRefs]; }
    getEventAiArticle           (entry) { return entry[this._Ix_Event_AiArticle]; }
    getEventAdditionalFields    (entry) { return entry[this._Ix_Event_AdditionalFields]; }

    isDurStart     (entry) { return this.getKey(entry).startsWith('Ds'); }
    isDurEnd       (entry) { return this.getKey(entry).startsWith('De'); }
    isDur          (entry) { return this.getKey(entry).startsWith('D'); }
    isEvent        (entry) { return this.getKey(entry).startsWith('E'); }
    isChapterEvent (entry) { return this.getKey(entry).startsWith('EC'); }

    _markers = new Map();


    /**************************************************************************/
    convertDurationEndKeyToStartKey (startKey)
    {
	return startKey.replace('e', 's');
    }

    
    /**************************************************************************/
    convertDurationStartKeyToEndKey (startKey)
    {
	return startKey.replace('s', 'e');
    }

    
    /**************************************************************************/
    /* Binary search to locate either an entry whose year offset matches a
       given year, or two entries which bracket the offset. */
    
    findBracketingEntries (year, type)
    {
	/**********************************************************************/
	const me = this;


	
	/**********************************************************************/
	function ignoreDurationEnds (ix)
	{
	    while (me.getKey(me.getEntryGivenIndex(ix)).startsWith('De'))
		--ix;
	    return me.getEntryGivenIndex(ix);
	}


	
	/**********************************************************************/
	year = JFrameworkUtils.convertToYearOffset(year);
	var low = 0;
	var high = this.getNumberOfEntries();

	while (low <= high)
	{
	    const mid = Math.floor((low + high) / 2);
	    var entryMid = this.getEntryGivenIndex(mid);
	    const midYear = this.getYearOffset(entryMid);

	    if (midYear === year)
	    {
		entryMid = ignoreDurationEnds(mid);
		
		if ('chapter' == type) // By default we find vanilla events.  Check if we've been asked to find a chapter pseudo event instead.
		{
		    var ix = mid;
		    var revisedEntry = null;
		    
		    while (true)
		    {
			if (++ix >= this.getNumberOfEntries())
			    break;

			const entry = this.getEntryGivenIndex(ix);
			const year = this.getYearOffset(entry);
			if (year != midYear)
			    break;

			if (this.getKey(entry).startsWith('EC'))
			{
			    revisedEntry = entry;
			    break;
			}
		    }

		    if (revisedEntry)
			entryMid = revisedEntry;
		}

		
		return { match: entryMid, prev: entryMid, next: entryMid };
	    }
	    else if (midYear < year)
		low = mid + 1;
	    else
		high = mid - 1;
	}

	const prev = ignoreDurationEnds(high) || null;
	const next = ignoreDurationEnds(low)  || null;
	return { match: null, prev: prev, next: next };
    }

    
    /**************************************************************************/
    getMarkerGivenKey (key)
    {
	return this._markers.get(key);
    }

    
    /**************************************************************************/
    /* All data items have a unique key, and it's convenient to have a map
       which relates the key to the data item. */
    
    index ()
    {
	this._keyMap = new Map(this.getEntries().map(inner => [inner[0], inner]));
    }

    
    /**************************************************************************/
    recordMarker (key, marker)
    {
	this._markers.set(key, marker);
    }


    /**************************************************************************/
    reformatData ()
    {
	for (var entryIx = 0; entryIx < this.getNumberOfEntries(); ++entryIx)
	{
	    const entry = this.getEntryGivenIndex(entryIx);

	    if (this.isEvent(entry))
	    {
		for (const fieldIx of [ /* this._Ix_YearDescription, */ this._Ix_Event_AiArticle, this._Ix_Event_AdditionalFields])
		    entry[fieldIx] = _ClassJChronologyUtilities.withLinks(entry[fieldIx]);
	    }
	}
    }
}

const JChronologyData = new _ClassJChronologyData();






/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                            Controls and menus                            **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                             Click handler                                **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
class _ClassClickHandlers
{
    /**************************************************************************/
    /* Selects a plain vanilla or chapter event on the timeline. */
    
    eventClickHandler (eventDiv)
    {
	_JChronologyPresentationHandler.selectEvent(eventDiv, false);
    }

    
    /**************************************************************************/
    handleLink (tag)
    {
	switch (tag.getAttribute('data-type'))
	{
	    case 'L': { JFrameworkStepDataAccessors.strongLinkToMap      (tag); break; }
	    case 'P': { JFrameworkStepDataAccessors.strongLinkToGenealogy(tag); break; }
	    case 'S': { _JChronologyPresentationHandler.setScriptureWindowContent(tag.dataset.ref); break; }
	}
    }


    /**************************************************************************/
    showDateHelp ()
    {
	const modal = document.getElementById('dateHelp');
	ModalDialogHandler.showModalDialog(modal);
	modal.querySelector('.jframework-modalDialogBody').scrollTop = 0;
	modal.style.top = '20px';
	modal.style.left = (window.innerWidth - modal.offsetWidth) / 2 + 'px';
    }

  
    /**************************************************************************/
    updateScriptureWindow (tag)
    {
	_JChronologyPresentationHandler.setScriptureWindowContent(tag.textContent.replace('?', ''));
    }
}

export const ClickHandlers = new _ClassClickHandlers();
window.ClickHandlers = ClickHandlers;




    
/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                                Controls                                  **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
class _ClassControlsHandler
{ 
    /**************************************************************************/
    hideWelcomeDialog ()
    {
	ModalDialogHandler.closeIfTopModalDialog(document.getElementById('welcomeDialog'));
    }

    
    /**************************************************************************/
    showHelpMenu ()
    {
	const modal = document.getElementById('help');
	ModalDialogHandler.showModalDialog(modal);
	modal.querySelector('.jframework-modalDialogBody').scrollTop = 0;
	modal.style.top = '20px';
	modal.style.left = (window.innerWidth - modal.offsetWidth) / 2 + 'px';
	modal.scrollTop = 0;
    }

  
    /**************************************************************************/
    showWelcome ()
    {
	this.showHelpMenu();
    }

  
    /**************************************************************************/
    showLayoutMenu ()
    {
	const modal = document.getElementById('layoutMenu')

	ModalDialogHandler.showModalDialog(modal);

	modal.style.top = '20px';
	modal.style.left = (window.innerWidth - modal.offsetWidth) / 2 + 'px';

	document.getElementById('horizontalSpacingSlider').value = CurrentHorizontalSpacingTicks;
	document.getElementById('verticalSpacingSlider').value = CurrentVerticalSpacingTicks;
	document.getElementById('numberOfGenerationsSlider').value = CurrentNumberOfGenerationsToGrowByOnEachExpansion;
    }
}

export const ControlsHandler = new _ClassControlsHandler();
window.ControlsHandler = ControlsHandler;





/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                           Presentation handler                           **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
class _ClassJChronologyPresentationHandler
{
    /**************************************************************************/
    _selectedEventDiv  = null;
    _selectedEventYear = null;
    _selectedNonEventPos = null;
    
    

    /**************************************************************************/
    /* Mainly intended for things like resizing, when we may end up doing a
       fair bit of redrawing, and may want to ensure that the original event
       is still selected. */
    
    reselectEventOrNonEvent ()
    {
	if (null !== this._selectedEventDiv)
	    this.selectEvent(this._selectedEventDiv);
	else
	    this.reselectNonEvent();
    }
    
    
    /**************************************************************************/
    reselectNonEvent ()
    {
	if (null !== this._selectedNonEventPos)
	    this.selectNonEvent(this._selectedNonEventPos);
    }

    
    /**************************************************************************/
    /* Updates info box, highlighting, etc, when a new selection is made. */
    
    _activeMarker = null;
    selectEvent (eventDiv, centreSelection = true)
    {
	_ClassImportantElements.getArbitraryDateMarker().style.display = 'none';
	
	const entry = JChronologyData.getEntryGivenElement(eventDiv);
	const isChapterEvent = JChronologyData.isChapterEvent(entry);
	
	if (isChapterEvent)
	{
	    const ref = JChronologyData.getEventYearDescription(entry).split('; ')[0].split('>')[1].split('<')[0];
	    this.setScriptureWindowContent(ref);
	    this._setInfoBoxContentForChapterEvent(entry);
	}
	else
	{
	    this.setScriptureWindowContent(JChronologyData.getEventScriptureRefs(entry));
	    this._setInfoBoxContentForStandardEvent(entry);
	}
	


	const thisMarker = JChronologyData.getMarkerGivenKey(JChronologyData.getKey(entry));
	if (null !== this._activeMarker)
	    this._activeMarker.classList.remove('jchronologyEventMarkerHighlight');
	this._activeMarker = thisMarker;
	this._activeMarker.classList.add('jchronologyEventMarkerHighlight');

	this._selectedEventDiv = eventDiv;
	this._selectedEventYear = JChronologyData.getEventDateLabel(entry).replace(' ', '');

	if (centreSelection)
	    JFrameworkUtils.centrePointVerticallyWithinScrollingContainer(_ClassImportantElements.getYearDescriptionsContainer(), this._selectedEventDiv.style.top);
    }


    /**************************************************************************/
    selectNonEvent (pos)
    {
	this._selectedEventDiv = null;
	this._selectedNonEventPos = pos;
	const marker = _ClassImportantElements.getArbitraryDateMarker();
	marker.style.top = pos + 'px';
	marker.style.display = 'block';
	JFrameworkUtils.centrePointVerticallyWithinScrollingContainer(_ClassImportantElements.getYearDescriptionsContainer(), pos);
    }


    /**************************************************************************/
    setScriptureWindowContent (scriptures)
    {
	if ('' === scriptures) return;
	JFrameworkMultiframeCommunicationsSlave.sendSetUrlForce('scripture', window.location.origin + '/?skipwelcome&q=' + 'reference=' + scriptures + '&options=VHN&noredirect');
    }


    /**************************************************************************/
    _copyLinkToClipboard ()
    {
	const entry = JChronologyData.getEntryGivenElement(this._selectedEventDiv);
	const key = JChronologyData.getKey(entry);
	const type = key.startsWith('EC') ? '&type=chapter' : '&type=event';
	const url = JFrameworkUtils.getFullUrl('html/J_AppsHtml/J_Chronology/j_chronologySplit3.html?year=' + this._selectedEventYear + type);
	navigator.clipboard.writeText(url);
	this._showPopUp('URL copied to clipboard', 'copyToClipboardConfirmation');
    }

	

    /**************************************************************************/
    /* Returns the info box with lazy evaluation. */
    
    _getInfoBox ()
    {
	if (!this.hasOwnProperty('_infoBox'))
	    this._infoBox = document.getElementById('info-box');
	return this._infoBox;
    }

    
    /**************************************************************************/
    /* Fills the info box for a pseudo event which represents a collection of
       sceripture dates associated with the given chapter. */
    
    _setInfoBoxContentForChapterEvent (entry)
    {
	/**********************************************************************/
	const infoBox = this._getInfoBox();
	const date = '<br><b>' + JChronologyData.getEventDateLabel(entry) + ':</b> ';
	const refs = JChronologyData.getEventYearDescription(entry);
	const caveatsA = refs.includes('?') ? ' (Question marks against references highlight chapters whose dates are particularly open to debate.)' : '';
	const intro = 'Events believed to have occurred around this year are mentioned in the chapter(s) listed below.' + caveatsA;


	
	/**********************************************************************/
	(async () => {
	    var content = date + intro + '<br><br>';
	    for (const ref of refs.split('; '))
	    {
		const chapterRef = ref.split('>')[1].split('<')[0];
		const link = _ClassJChronologyUtilities.withChapterScriptureLinks(ref);
		var associatedText = await JFrameworkChapterSummaries.instance().getChapterSummary(chapterRef);
		if (!associatedText) associatedText = '&mdash;';
		associatedText = _ClassJChronologyUtilities.withLinks(associatedText);
		associatedText = '<p>' + link + ': ' + associatedText.replaceAll('', '</p><p class="indentedPara">') + '</p><br>';
		content += associatedText;
	    }

	    content = content.slice(0, -4);

	    infoBox.innerHTML =
		`<div style='display:flex; align-items:center'>
                  <span id='shareableLink' class='jframework-linkAsButton' style='margin-left:auto' title='Copy to clipboard a URL for this event'>Shareable link</span>
                </div>
                ${content}`;
	})();
	


	/**********************************************************************/
	infoBox.querySelector('#shareableLink').addEventListener('click', () => this._copyLinkToClipboard());



	/**********************************************************************/
	infoBox.scrollTop = 0;
    }
    

    /**************************************************************************/
    /* Does what it says on the tin. */
    
    _setInfoBoxContentForStandardEvent (entry)
    {
	const infoBox = this._getInfoBox();
	const date = '<b>' + JChronologyData.getEventDateLabel(entry) + ':</b> ';
	const shortDescription = _ClassJChronologyUtilities.withLinks(JChronologyData.getEventYearDescription(entry));
	const scriptures = JChronologyData.getEventScriptureRefs(entry);
	const extraBiblicalRefs = JChronologyData.getEventExtraRefs(entry);
	const longDescription = JChronologyData.getEventAiArticle(entry);

	var caveatsA = '';
	var caveatsB = '';
	if (JChronologyData.getEventFlags(entry).includes('~')) caveatsA = 'Date is approximate.';
	if (JChronologyData.getEventFlags(entry).includes('*')) caveatsB = 'This event is one of a collection which different chronologies place in different orders.';

	if ('' !== caveatsA && '' !== caveatsB) caveatsA += '<br>';
	caveatsA += caveatsB;
	if ('' !== caveatsA) caveatsA = '<br><br>' + caveatsA;

	var content = date + shortDescription + (shortDescription.endsWith('.') ? '' : '.') + caveatsA + '<br><br>';
	if ('' != scriptures) content += '<b>Scripture references:</b> ' + scriptures + '<br><br>';
	if ('' != extraBiblicalRefs) content += '<b>External references:</b> ' + extraBiblicalRefs + '<br><br>';
	content += longDescription;
	
	infoBox.innerHTML =
             `<div style='display:flex; align-items:center'>
                <span id='shareableLink' class='jframework-linkAsButton' style='margin-left:auto' title='Copy to clipboard a URL for this event'>Shareable link</span>
              </div>
              ${content}`;

	infoBox.querySelector('#shareableLink').addEventListener('click', () => this._copyLinkToClipboard());

	infoBox.scrollTop = 0;
    }
    

    /**************************************************************************/
    _showPopUp (message, popUpId, duration = 1000)
    {
	const popup = document.getElementById(popUpId);
	popup.textContent = message;
	popup.style.display = "block";
	popup.style.opacity = "1";

	// Fade out after 'duration' milliseconds
	setTimeout(() => {
	    popup.style.opacity = "0";
	    setTimeout(() => {
		popup.style.display = "none";
	    }, 1000); // Wait for fade-out transition to finish
	}, duration);
    }
}

const _JChronologyPresentationHandler = new _ClassJChronologyPresentationHandler();





/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                                Utilities                                 **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
class _ClassJChronologyUtilities
{
    /**************************************************************************/
    static C_Dbg = false;
    // static C_DurationColours = ['red', 'orange', 'yellow', 'green', 'blue', 'violet']; // My original colours, chosen to make distinctions apparent.
    static C_DurationColours = ['black', 'blue', 'green', 'red' ]; // DIB's preferred scheme, chosen to make similarities obvious.
    static C_DurationsColumn = 'L';
    static C_LastAmDate = 2083;


    /**************************************************************************/
    static getChannelLeft (timeline, channelNo)
    {
	const durationLineWidth= this.getDurationLineWidth(); // parseFloat(getComputedStyle(document.getElementById('jchronologyEventLabels')).width) / 6;
	const durationLineSeparation = this.getDurationLineSeparation();
	const horizontalBasePos = 'R' == this.C_DurationColumn ? 0 : durationLineSeparation + parseFloat(timeline.style.left) + parseFloat(getComputedStyle(timeline).width);
	return (horizontalBasePos + channelNo * (durationLineWidth + durationLineSeparation));
    }

    
    /**************************************************************************/
    static getDurationLineSeparation ()
    {
	return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--jChronologyDurationLineSeparation'));
    }

    
    /**************************************************************************/
    static getDurationLineWidth ()
    {
	return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--jchronologyDurationLineWidth'));
    }

    
    /**************************************************************************/
    /* The yearDescription field may contain down-arrows, linking it to the
       duration lines.  The link is establised using colours.  Links are marked
       in the incoming data by jChronDurationLinktags - all we need do here is
       convert them to spans. */
    
    static withDurationColours (s)
    {
	return s.replaceAll('jChronDurationLink', 'span');
    }

    
    /**************************************************************************/
    /* The data as suppplied contains <jChronLink ...> tags in selected fields,
       naming people or places, and giving the appropriate Strongs tags.
       This method turns them into clickable items. */
    
    static withLinks (s)
    {
	return s
	    .replaceAll('<jLink', '<span class="jframework-linkAsButton"')
	    .replaceAll('jLink', 'span')
	    .replaceAll('clickHandler', "onclick='ClickHandlers.handleLink(this)'");
    }


    /**************************************************************************/
    /* Takes the data associated with a chapter pseudo event and returns
       something which makes the individual scriptures clickable. */
    
    static withChapterScriptureLinks (s)
    {
	return s
	    .replaceAll('<jChronChapterDate>', '<span class="jframework-linkAsButton" onclick="ClickHandlers.updateScriptureWindow(this)">')
	    .replaceAll('</jChronChapterDate>', '</span>');
    }


    
    /**************************************************************************/
    /* See withLinks.  This removes the link tags, but retains
       their content. */
    
    static withoutLinks (s)
    {
	return s.replace(/<jLink[^>]*>/g, '')
	        .replaceAll('</jLink>', '');
    }
}





/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                            Important elements                            **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/* Things which are possibly going to be required quite frequently.  The idea
   is that I do lazy evaluation here, so I find the relevant elements only
   when they are needed, and then do not need to rescan the DOM if they are
   needed again. */

class _ClassImportantElements
{
    static _arbitraryDateMarker = null;
    static getArbitraryDateMarker () { return _ClassImportantElements._arbitraryDateMarker; } // The marker used when asked to select a date which does not exist in hte events list.
    static setArbitraryDateMarker (marker) { _ClassImportantElements._arbitraryDateMarker = marker; }


    static _durationHeadersButtonOverlay = null;
    static getDurationHeadersButtonOverlay () // An overlay to getDurationHeaderContainer which holds the help button.
    {
	if (null === _ClassImportantElements._durationHeadersButtonOverlay)
	    _ClassImportantElements._durationHeadersButtonOverlay = document.getElementById('jchronologyDurationHeadersButtonOverlay');
	return _ClassImportantElements._durationHeadersButtonOverlay;
    }
    

    static _durationHeaderContainer = null;
    static getDurationHeaderContainer () // The div at the top of the graphics area which gives headers for things only partially visible.
    {
	if (null === _ClassImportantElements._durationHeaderContainer)
	    _ClassImportantElements._durationHeaderContainer = document.getElementById('jchronologyDurationHeaders');
	return _ClassImportantElements._durationHeaderContainer;
    }


    static _timeline = null;
    static getTimeline () { return _ClassImportantElements._timeline; } //  Will be set to the actual vertical line which represents the timeline.
    static setTimeline (div) { _ClassImportantElements._timeline = div; }


    static _chronologyContainer = null;
    static getChronologyContainer () // The div which holds the whole of the lower part of the screen.
    {
	if (null === _ClassImportantElements._chronologyContainer)
	    _ClassImportantElements._chronologyContainer = document.getElementById('jchronologyContainer');
	return _ClassImportantElements._chronologyContainer;
    }

    static _timelineContainer = null;
    static getTimelineContainer () // The div which holds the timeline and associated graphics.
    {
	if (null === _ClassImportantElements._timelineContainer)
	    _ClassImportantElements._timelineContainer = document.getElementById('jchronologyTimeline');
	return _ClassImportantElements._timelineContainer;
    }


    static _yearDescriptionsContainer = null;
    static getYearDescriptionsContainer () // The portion of the graphics area which holds the year descriptions.
    {
	if (null === _ClassImportantElements._yearDescriptionsContainer)
	    _ClassImportantElements._yearDescriptionsContainer = document.getElementById('jchronologyYearDescriptions');
	return _ClassImportantElements._yearDescriptionsContainer;
    }
}
