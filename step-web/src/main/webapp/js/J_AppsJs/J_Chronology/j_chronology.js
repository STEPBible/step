/******************************************************************************/
/* Displays chronology details.

   The details are shown on a vertical line, spaced in a 'reasonably' optimal
   manner (although this does mean that the user may have to scroll to see all
   of them).

   The caller should supply a div when calling init, and the chronology
   functionality is placed within that div.

   The data is generated by a Kotlin program 'FormatChronologyData', based upon
   data which is extracted manually from https://docs.google.com/spreadsheets/d/15WmvZ4C-6G62Cd9JuIvtcqGfJ_vEhi6YohSht4fmZZg/edit?gid=0#gid=0.

   See JChronologyData for more details.



   External access via URLs
   ========================

   showWelcome: If this appears as a URL parameter, it causes the welcome
     screen to be shown on entry.  In fact we may or may not allow for a
     welcome screen -- the jury is still out.  If used at all, I anticipate
     it will only be when coming from the Resources menu, and I will _probably_
     arrange for it to be shown only once.

   year=1000BC: This may be any date at all.  If the date corresponds to a
     particular event (or to the start of a duration, which is treated as
     though it were an event), that event is selected and made visible.
     If it does not have an associated event, things are positioned
     somewhere near the element.  The date should include one of AD, BC or
     AM (but no space).  I don't mind whether the letters are placed at the
     beginning or the end.  Dates are based upon the 'ModernDate' column of
     the chronology data.

   No year parameter: Acts as though year=6BC had been specified.  This
     corresponds to the nearest populated year to what would be AD 0 if
     such a date existed.



  External access via interframe communications
  =============================================

  At the time of writing, this relates purely to calls from the search frame,
  which is handled by a message containing a 'key' field.
*/
/******************************************************************************/

'use strict';

import { JFrameworkStepDataAccessors }                  from '/js/J_AppsJs/J_Framework/j_framework.stepDataAccessors.js';
import { ClassJFrameworkDraggable }                     from '/js/J_AppsJs/J_Framework/j_framework.draggable.js';
import { ClassJFrameworkModalDialog }                   from '/js/J_AppsJs/J_Framework/j_framework.modalDialog.js';
import { ClassJFrameworkMultiframeCommunicationsSlave } from '/js/J_AppsJs/J_Framework/j_framework.multiframeCommunicationsSlave.js';
import { JChronologyData }                              from '/js/J_AppsJs/J_Chronology/j_chronologySharedCode.js';
import { JFrameworkSharedConstants }                    from '/js/J_AppsJs/J_Framework/j_framework.sharedConstants.js';
import { JFrameworkUserSettings }                       from '/js/J_AppsJs/J_Framework/j_framework.userSettings.js';
import { JFrameworkUtils }                              from '/js/J_AppsJs/J_Framework/j_framework.utils.js';
import { JFrameworkChapterSummaries }                   from '/js/J_AppsJs/J_Framework/j_framework.chapterSummaries.js';

export const ModalDialogHandler = new ClassJFrameworkModalDialog();
window.ModalDialogHandler = ModalDialogHandler;





/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                                   Main                                   **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
class _ClassJChronology extends ClassJFrameworkMultiframeCommunicationsSlave
{
    /**************************************************************************/
    /* We need to obtain the data and then run the bulk of the processing.  To
       that end, I have to pass something which does the bulk processing as an
       argument to the read method. */

    onload (container)
    {
	this._container = container;

	JFrameworkSharedConstants.setHrefs(); // The document make contain jframeworkLink tags which include logical names for target URLs.  This converts the names to 'proper' addresses.
	
	JChronologyData.loadData(this._onload.bind(this)); // Get the data.
	
	ModalDialogHandler.addModalCloseButtonHandlers(); // Add close handlers to everything which has a close button.
	
	ClassJFrameworkDraggable.initialise(); // Make any appropriate pop-ups draggable.

	document.getElementById('alternativeChronologyOk').addEventListener('click', () => {
	    JEventHandlers.alternativeChronologiesSelectorOk();
	});

	document.getElementById('alternativeChronologyCancel').addEventListener('click', () => {
	    JEventHandlers.alternativeChronologiesSelectorCancel();
	});
    }


    /*************************************************************************/
    /* Receives inter-iframe messages and processes them. */

    receiveMessage (data, callingFrameId)
    {
	_JChronologyPresentationHandler.selectAnnotatedYear(JChronologyData.getMarkerGivenKey(data.key));
    }

    
    /**************************************************************************/
    resize ()
    {
	JRenderer.adjustDimensionsAndPositions();
	JRenderer.doDurationHeaders();
	this._respondToFrameWidthChanges();
    }

    
    /**************************************************************************/
    /* The URL for the present page may be 'revised' (including set up for the
       first time) either because of a direct intervention from the 3-panel
       page, or because the people index pane has been used to select a new
       person.

       The former occurs where the 3-panel has been invoked from the sidebar
       as a result of someone looking up Strong's information while reading
       scripture.  The latter (ie when invoked from the people index) occurs
       when already in 3-pane mode, and selecting a new person.

       There is also the possibility that the present code may be called with
       no selection at all, in which case I have been asked to default to
       Aaron. */
  
    _makeInitialSelection ()
    {
	/**********************************************************************/
	const urlParms = new URLSearchParams(new URL(window.location.href).search);
	var year = urlParms.get('year') ?? '6BC'; // Date Jesus born.
	var showWelcome = urlParms.has('showWelcome');
	var type = urlParms.get('type') ?? 'event';



	/**********************************************************************/
	const selection = JChronologyData.findBracketingEntries(year, type);
	if (null === selection.match) // A date not actually marked on the timeline.
	{
	    const unifiedYear = JFrameworkUtils.convertToUnifiedYear(year);
	    const pos = unifiedYear < JChronologyData.getLastUyearInAm() ? JRenderer.rawPositionForAmDate(unifiedYear) : JRenderer.rawPositionForNonAmDate(unifiedYear);
	    _JChronologyPresentationHandler.selectNonAnnotatedYear(pos);
	}	    
	else
	{
	    const key = JChronologyData.getKey(selection.match);
	    const matchingDiv = JChronologyData.getMarkerGivenKey(key);
	    _JChronologyPresentationHandler.selectAnnotatedYear(matchingDiv);
	}



	/**********************************************************************/
	if (showWelcome)
	{
	    if (null == localStorage.getItem('chronologyHaveShownWelcome'))
	    {
		localStorage.setItem('chronologyHaveShownWelcome', 'Yes');
		JEventsHandler.showWelcome();
	    }
	}
    }


    /**************************************************************************/
    /* Carries out initialisation once all of the data has been loaded. */
    
    _onload ()
    {
	/**********************************************************************/
	/* Set up the modal used to select alternative chronologies. */
	
	_ClassAlternativeChronologies.init();


	
	/**********************************************************************/
	/* Determine the width of the frame, so that things are initialised to
	   have the correct visibility. */
	
	this._updateFrameWidth();


	
	/**********************************************************************/
	/* Some of the fields are supplied in at most partly finished form.
	   These need to be updated to take into account how we actually want
	   to process them. */
	
	JChronologyData.reformatData(JChronologyData.withLinks);


	
	/**********************************************************************/
	/* Creates various bits and pieces needed in the graphical part of the
	   display, works out how things need to be spaced, and then positions
	   them. */
	
	JRenderer.render('onload');



	/**********************************************************************/
	/* Event callbacks. */

	window.addEventListener('load',   this.resize.bind(this));
	window.addEventListener('resize', this.resize.bind(this));
//	if (document.fonts && document.fonts.ready)
//	    document.fonts.ready.then(this.resize.bind(this));



	/**********************************************************************/
	/* Throttle to improve performance when scrolling the thing which
	   contains the duration lines. */
	
	const me = this;
	const container = _ClassCommon.getColumnsContainer();
	var durationScrollTimeout = null;
	container.addEventListener("scroll", () => {
	    if (durationScrollTimeout) return;
	    durationScrollTimeout = requestAnimationFrame(() => {
		JRenderer.doDurationHeaders();
		durationScrollTimeout = null;
	    });
	});




	/**********************************************************************/
	/* Arrange to respond to changes the user makes to the setting --
	   colours, font sizes, etc. */
	
	function fnUserSettingsChanged (firstTime)
	{
	    const background = _ClassCommon.getVariableSetting('--clrBackground');
	    const isDark = JFrameworkUtils.isDark(background);
	}
	JFrameworkUserSettings.init(fnUserSettingsChanged);



	/**********************************************************************/
	this._makeInitialSelection();
    }

	
    /**************************************************************************/
    _respondToFrameWidthChanges ()
    {
	if (this._updateFrameWidth())
	    JRenderer.render();
    }


    /**************************************************************************/
    /* Determines if the screen changes have resulted in the chronology frame
       going from 'wide' to 'narrow' or vice versa (sizes defined here).  If
       so, changes class settings in the body to deal with things whose
       visibilty has to depend upon frame width. */
    
    _updateFrameWidth ()
    {
	const containerWidth = parseFloat(window.getComputedStyle(_ClassCommon.getContentContainer()).width);
	if (containerWidth > 500)
	{
	    if (document.body.classList.contains('isWideScreen')) return false;
	    document.body.classList.remove('isNarrowScreen');
	    document.body.classList.add('isWideScreen');
	}
	else
	{
	    if (document.body.classList.contains('isNarrowScreen')) return false;
	    document.body.classList.add('isNarrowScreen');
	    document.body.classList.remove('isWideScreen');
	}

	return true;    }
}

export const JChronology = new _ClassJChronology();





/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                               Renderering                                **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
class _ClassJRenderer
{
    /**************************************************************************/
    /* Configuration data.  This isn't intended to be changed dynamically:
       I have it here merely because I don't think we've necessarily pinned
       down all aspects of how we want the layout to work. */
    
    _additionalSpacingAfterSameYearAsPrevious = 0; // If we have two lines both for the same year (which is the most we can ever have) permits some extra spacing to be introduced after them.
    _gapBetweenLines = 6; // Space between consecutive text lines (px), to aid readability.
    _headerAndTrailerHeight = 20; // A short piece of timeline at top and bottom of the screen so that things don't cut off too abruptly.
    _mergeChapterEventsWithPreviousVanillaEvent = false;
    _suppressRepeatedDates = true;
    _suppressMarkersAndDatesForChapters = true;
    
    
    
    /**************************************************************************/
    render (callType = '')
    {
	//console.time("renderYears");
	const durationDetails = this._renderYears(); // Maps start keys to the start/end divs which will demarcate the duration line.
	//console.timeEnd("renderYears");

	this.adjustDimensionsAndPositions();
	this._renderDurations(durationDetails);
	if ('onload' != callType)
	    this.doDurationHeaders();
    }


    /**************************************************************************/
    /* We have a number of columns which constitute the main body of
       the graphical part of the display.  The last soaks up whatever
       space is available to it, but the others need to be set to be
       just wide enough for their content.  We also need to set the
       height of the timeline to be long enough to accommodate all of
       the events. */
    
    adjustDimensionsAndPositions (colWidthsOnly = false)
    {
	/**********************************************************************/
	/* Calculates the width needed to fit a column to its content. */
	
	function fitToContentRightJustified (id)
	{
	    const inner = _ClassCommon.getVerticalDiv(id);
	    const children = Array.from(inner.children);

	    var maxWidth = 0;
	    
	    children.forEach(child => {
		if (!child.classList.contains('jchronologyTickMarkHolder')) // These are the lozenges which show regular dates.  For some reason I can't get reasonable widths for them.
		{
		    const style = getComputedStyle(child);		
		    const childWidth = child.offsetWidth + parseFloat(style.marginLeft) + parseFloat(style.marginRight);
		    if (childWidth > maxWidth)
			maxWidth = childWidth;
		}

	    });

	    return maxWidth + 5; // Extra little bit to ensure the text doesn't hit the left edge.
	}


	
	/**********************************************************************/
	/* The column widths. */
	
	const widths = [];
	var ix = -1;
	
	for (const id of _ClassCommon.getVerticalDivIds())
	{
	    switch (id) // Make sure you keep this aligned with the details in _ClassCommon.
	    {
		case 'jchronologySelectedItemHighlighterHolder':
		{
		    widths.push(0);
		    break;
		}

		case 'jchronologyOtherDates':
		case 'jchronologyModernDates':
		{
		    widths.push(fitToContentRightJustified(id));
		    break;
		}

		case 'jchronologyTimelineHolder':
		{
		    widths.push(_ClassJChronologyUtilities.getWidthOfTimelineHolderDiv());
		    break;
		}

		case 'jchronologyDurationLines':
		{
		    widths.push(_ClassJChronologyUtilities.getWidthOfDurationLinesDiv());
		    break;
		}

		case 'jchronologyYearDescriptions':
		{
		    break; // Deliberately not setting a width here.
		}
	    }
	}



	/**********************************************************************/
	/* Apply the widths. */
	
	const template = widths.join('px ') + 'px 1fr';
	_ClassCommon.getColumnsContainer().style.gridTemplateColumns = template;



	/**********************************************************************/
	if (colWidthsOnly)
	    return;



	/**********************************************************************/
	/* Sort out the height of the column container.  In theory you can do
	   this directly in CSS, but I haven't managed to find a way to do
	   that _and_ have a vertical scroll bar too when needed. */

	const header = document.getElementById('HEADER');
	const footer = document.getElementById('FOOTER');
	const content = _ClassCommon.getColumnsContainer();

	const headerHeight = header.offsetHeight;
	const footerHeight = footer.offsetHeight;
	const viewportHeight = window.innerHeight;

	const contentHeight = viewportHeight - headerHeight - footerHeight;
	content.style.height = contentHeight + 'px';

	
	
	/**********************************************************************/
	/* Make the width of the button overlay the same as the offset of the
	   timeline.  This then makes it possible to position the date help
	   button centrally over the dates. */
	
	// $$$ document.getElementById('jChronologyDateInfoButton').style.width = (widths[0] + widths[1]) + 'px';



	/**********************************************************************/
	/* The timeline needs to be long enough to run the entire height of the
	   content. */
	
	const height = Math.max(..._ClassCommon.getVerticalDivs().map(d => d.scrollHeight))
	const timeline = document.getElementById('jchronologyTimeline');
	timeline.style.top = 0;
	timeline.style.left = ((_ClassJChronologyUtilities.getWidthOfTimelineHolderDiv() - parseFloat(_ClassCommon.getVariableSetting('--timelineWidth'))) / 2) + 'px';
	timeline.style.height = height + 'px';
	


	/**********************************************************************/
	/* Force all columns to be the same height. */
	
	const abs = document.querySelector('.jchronologyAbsoluteContent');
	const col = document.querySelector('.jchronologyBodyColumn:last-child');
	_ClassCommon.getVerticalDivs().forEach( d => d.style.height = abs.scrollHeight + 'px' );



	/**********************************************************************/
	/* Force the overflow box to have the same width as the main body, so
	   that horizontal scrolling works. */

	const widthSetter = document.getElementById('jchronologyDurationHeadersScrollSupport');
	widthSetter.style.width = _ClassCommon.getColumnsContainer().scrollWidth + 'px';
	widthSetter.style.overflow = 'hidden';
    } // adjustDimensions


    /**************************************************************************/
    /* We need to check when duration bars overlap the top of the graphics
       area so as to be able to update the div which tells the user about
       them. */
    
    doDurationHeaders ()
    {
	/**********************************************************************/
	/* Does the header for a single item. */
	
	const durationHeaderContainer = _ClassCommon.getDurationHeaderContainer();
	const timeline = _ClassCommon.getDurationLinesContainer();
	const linePosition = this._linePosition;
	var nDisplayableEntries = -1;
	
	function renderHeaderForItem (durationLineDiv)
	{
	    const entry = JChronologyData.getEntryGivenElement(durationLineDiv);
	    const channelNo = JChronologyData.getDurStartChannelNo(entry);
	    const line = document.createElement('div');
	    line.className = 'jchronologyDurationHeaderLine';
	    line.style.left = (_ClassCommon.getVerticalDivHorizontalPosition('jchronologyDurationLines').left + _ClassJChronologyUtilities.getChannelLeft(channelNo)) + 'px';
	    line.style.height = (1 + (1.5 * --nDisplayableEntries)) + 'em';

	    const label = document.createElement('div');
	    label.className = 'jchronologyDurationHeaderLabel';
	    label.textContent = JChronologyData.getDescription(entry);

	    var colour = getComputedStyle(durationLineDiv).backgroundColor;
	    line.style.borderLeftColor = colour;
	    label.style.color = colour;

	    const unifiedYear = JChronologyData.getUnifiedYear(entry);
	    const bracketingEntries = JChronologyData.findBracketingEntries(unifiedYear, 'event');
	    if (bracketingEntries.match)
	    {
		label.style.cursor = 'pointer';
		label.addEventListener('click', () => {
		    const key = JChronologyData.getKey(bracketingEntries.match);
		    const matchingDiv = JChronologyData.getMarkerGivenKey(key);
		    _JChronologyPresentationHandler.selectAnnotatedYear(matchingDiv, true);
		});
	    }

	    
	    line.appendChild(label);
	    durationHeaderContainer.appendChild(line);
	}
	


	/**********************************************************************/
	/* We need to remove any existing lines and labels. */

	Array.from(durationHeaderContainer.children).forEach(child => {
	    child.remove();
	});



	/**********************************************************************/
	/* Find out which items, if any, need to be displayed. */
	
	const containerScrollTop = _ClassCommon.getColumnsContainer().scrollTop;
	function spansTop (child)
	{
	    // Child's top within column/content (handles inline CSS or stylesheet).
	    const childTop = parseFloat(getComputedStyle(child).top) || 0;
	    
	    // Element height including borders.
	    const childBottom = childTop + child.offsetHeight;

	    return (childTop <= containerScrollTop) && (childBottom > containerScrollTop);
	}


	const reports = [];
	this._durationLines.forEach(item => {
	    if (spansTop(item))
		reports.push(item);
	});



	/**********************************************************************/
	/* Order elements by channel no. */

	function orderFn (durationLineDiv)
	{
	    const entry = JChronologyData.getEntryGivenElement(durationLineDiv);
	    return JChronologyData.getDurStartChannelNo(entry);
	}


	
	/**********************************************************************/
	nDisplayableEntries = reports.length;
	reports.sort((a, b) => orderFn(a) - orderFn(b));
	reports.forEach(item => {
	    renderHeaderForItem(item);
	});
    }

    
    /**************************************************************************/
    /* Given a unified year, works out where to position it vertically. */
    
    rawPositionForAmDate (unifiedYear)
    {
	return this._headerAndTrailerHeight + unifiedYear * _ClassCommon.getVerticalSpacePerYearForAmDates();
    }

    rawPositionForNonAmDate (unifiedYear)
    {
	return this._lastPosInAm + (unifiedYear - this._lastUnifiedYearInAm) * _ClassCommon.getVerticalSpacePerYearForNonAmDates();
    }

    
    /**************************************************************************/
    _addTickMarks ()
    {
	/**********************************************************************/
	/* Gets a list of the tops and bottoms of all date labels. */
	
	const labelHeight = document.getElementById('getLabelSizeForTickMarks').offsetHeight;
	const mainFontSize = parseFloat(_ClassCommon.getVariableSetting('--defaultFontSize'));
	const existingDateLabelIntervals = [..._ClassCommon.getVerticalDiv('jchronologyModernDates').querySelectorAll('.jchronologyTimelineElement')]
	      .map(el => {
		  var parent = el.offsetParent;
		  var top = el.offsetTop;
		  var bottom = top + mainFontSize + 2;
		  return { top, bottom };
	      })
	      .sort((a, b) => a.top - b.top);



	/**********************************************************************/
	/* Looks for a clash between the putative new element and any of the
	   original date labels. */
	
	function clash (intervals, newTop, newBottom)
	{
	    var lo = 0;
	    var hi = intervals.length - 1;

	    while (lo <= hi)
	    {
		const mid = (lo + hi) >> 1;
		const cur = intervals[mid];

		if (newBottom < cur.top)
		    hi = mid - 1; // new element is above this interval
		else if (newTop > cur.bottom)
		    lo = mid + 1; // new element is below this interval
		else 
		    return true; // OVERLAP FOUND
	    }
	    return false;
	}


	/**********************************************************************/
	/* Constructs a tick mark element. */
	
	function makeElement (pos, label)
	{
	    if ('0 BC' == label) label = '&nbsp;&nbsp;0&nbsp;&nbsp;';
	    const eventDateAndMarkerDiv = document.createElement('div');
	    eventDateAndMarkerDiv.className = 'jchronologyTickMarkHolder';
	    eventDateAndMarkerDiv.style.top = pos + 'px';
	    const dateDiv = document.createElement('div');
	    dateDiv.classList.add('jchronologyTickMarkDateLabel');
	    dateDiv.innerHTML = label;
	    eventDateAndMarkerDiv.appendChild(dateDiv);
	    _ClassCommon.getVerticalDiv('jchronologyModernDates').appendChild(eventDateAndMarkerDiv);
	    return eventDateAndMarkerDiv;
	}



	/**********************************************************************/
	const me = this;
	function makeAmPos (uyear)
	{
	    return me.rawPositionForAmDate(uyear) + labelHeight / 2;
	}

	function makeBcPos (year)
	{
	    const uyear = JChronologyData.getAdBcOffset() - year;
	    return me.rawPositionForNonAmDate(uyear) + labelHeight / 2;
	}

	function makeAdPos (year)
	{
	    const uyear = JChronologyData.getAdBcOffset() + year;
	    return me.rawPositionForNonAmDate(uyear) + labelHeight / 2;
	}


	
	/**********************************************************************/
	const C_AmInterval = 50;
	var start = 0;
	var uyear = 0;
	while (uyear < JChronologyData.getFirstUYearBc())
	{
	    const pos = makeAmPos(uyear);
	    if (!clash(existingDateLabelIntervals, pos - labelHeight, pos + labelHeight))
		makeElement(pos, 'AM ' + uyear);
	    uyear += C_AmInterval;
	}


	
	/**********************************************************************/
	const C_BcInterval = 5;
	var year = Math.floor( (1 + JChronologyData.getFirstUYearBc()) / C_BcInterval) * C_BcInterval;
	while (year >= 0)
	{
	    const pos = makeBcPos(year);
	    if (!clash(existingDateLabelIntervals, pos - labelHeight, pos + labelHeight))
		makeElement(pos, year + ' BC');
	    year -= C_BcInterval;
	}


	
	/**********************************************************************/
	const C_AdInterval = 5;
	var year = C_AdInterval;
	while (year < JChronologyData.getLastAsActualYear())
	{
	    const pos = makeAdPos(year);
	    if (!clash(existingDateLabelIntervals, pos - labelHeight / 2, pos + labelHeight / 2))
		makeElement(pos, year + ' AD');
	    year += C_AdInterval;
	}
    }


    /**************************************************************************/
    _durationLines = [];
    _renderDuration (startAndEnd)
    {
	/**********************************************************************/
	/* Data from chronology database. */
	
	const dataEntry = JChronologyData.getEntryGivenElement(startAndEnd[0]);
	const colour = JChronologyData.getDurStartColour(dataEntry);
	const channelNo = JChronologyData.getDurStartChannelNo(dataEntry);
	const isRegency = JChronologyData.getDurStartIsRegency(dataEntry);



	/**********************************************************************/
	/* Relatively fixed information. */
	
	const verticalStartPos = parseFloat(startAndEnd[0].style.top);
	const verticalEndPos   = parseFloat(startAndEnd[1].style.top);



	/**********************************************************************/
	/* Create and position the div which will represent this duration. */
	
	const newLine = document.createElement('div'); this._durationLines.push(newLine);
	_ClassCommon.getDurationLinesContainer().appendChild(newLine);
	newLine.classList.add('jchronologyDurationLine');
	newLine.style.left = _ClassJChronologyUtilities.getChannelLeft(channelNo) + 'px';
	newLine.style.background = colour;
	newLine.style.setProperty('--lineColour', colour); // We need this in order for CSS to draw the down-arrow at the start of the line in the correct colour.
	newLine.style.height = (verticalEndPos - verticalStartPos - parseFloat(_ClassCommon.getVerticalGapBetweenConsecutiveDurationLines())) + 'px'; // The parseFloat gives some space at the bottom of each line,
	                                                                                                                                              // so that if one line ends and another starts at the same date,
 	                                                                                                                                              // we can see a break between the two.
	newLine.style.top = `${verticalStartPos}px`;
	newLine.setAttribute('data-key', startAndEnd[0].getAttribute('data-key'));

	if (isRegency)
	    newLine.classList.add('regency');
//	    newLine.style.background = `repeating-linear-gradient(to bottom, ${colour} 0 10px, yellow 10px 20px)`;

	if (_ClassJChronologyUtilities.C_Dbg)
	{
	    const info = `Key: ${key}  Col: ${channelNo}  Top: ${verticalStartPos}  Bottom: ${verticalEndPos} Date: ${JChronologyData.getAnnotatedYearModernDate(dataEntry)}`;
	    console.log(info);
	    newLine.addEventListener('click', function (event) {
		alert(info);
	    });
	}
    }

    
    /**************************************************************************/
    _renderDurations (durationDetails)
    {
	const durationDetailsByUnifiedYear = new Map();
	for (const key of durationDetails.keys())
	{
	    const startAndEndDiv = durationDetails.get(key);
	    const entry = JChronologyData.getEntryGivenElement(startAndEndDiv[0]);
	    const unifiedYear = JChronologyData.getUnifiedYear(entry);

	    if (!durationDetailsByUnifiedYear.has(unifiedYear)) // Note that while no two _events_ share the same date, more than one duration can have the same start date, so we need a multimap here.
		durationDetailsByUnifiedYear.set(unifiedYear, []);
	    durationDetailsByUnifiedYear.get(unifiedYear).push(startAndEndDiv);
	}

	const sortedUnifiedYears = [...durationDetailsByUnifiedYear.keys()].sort((a, b) => a - b);
	for (const unifiedYear of sortedUnifiedYears)
	{
	    const startAndEndDivs = durationDetailsByUnifiedYear.get(unifiedYear);
	    startAndEndDivs.forEach( (item, index) => { this._renderDuration(item); });
	}
	
	_JChronologyPresentationHandler.reselectAnnotatedOrNonAnnotatedYear();
    }


    /**************************************************************************/
    /* The layout comprises four divs, side by side.  Within each of these
       I create a sub-div to hold the content.  Which sounds weird, but this
       way, I can create the content outside of the document and then simply
       add these subdivs when the content is complete -- an approach which
       speeds the initial rendering up very appreciably.

       From left to right, the divs hold the 'Other' date, the 'Modern' date,
       the markers and duration lines, and the year description.

       The entries which appear here are as follows:

       - AnnotatedYears have a date and a description.  These cover
         years for which we have event details (like the accession of
         monarchs or whatever).  Where the year in question also
         appears in our chapter-to-year data as being a year which is
         coverted by one or more scripture chapters, the scripture
         information also appears as part of the description.

       - There are 'chapter' lines, which indicate that a given collection
         of chapters are believed to cover a particular year.  These
	 appear only if the year in question does not have an AnnotatedYear
	 line.  (As mentioned above, where this is the case, the information
	 from the chapter line is merged into that for the AnnotatedYear.)

       - There are duration-start and duration-end events, which indicate
         when some enduring situation starts and ends -- the regnal
	 period for a king perhaps.

       - And there may be what I refer to here as tick marks.  These are
         regular indications of dates, mainly to help when scrolling
	 through wastelands where we have no other information.  Having
	 these labels displayed helps make it clear that the scrolling is
	 actually achieving something.


       AnnotatedYears and Chapter lines are visible and clickable.  Clicking
       on them causes the info box and scripture window to be updated to
       contain information about the year and / or the chapters.

       Duration -start and -end do not produce visible lines of text: rather,
       they give rise to vertical lines representing the duration in question.
       They occupy something of a shadow land.  It is convenient to include
       them in the processing as though they were genuine events, because then
       the re-rendering associated with resize events can arrange that they,
       too, are appropriately repositioned.  But we don't want them to be
       visible as though they were actual events, which I achieve via
       z-order, leaving their text content empty, and not given them a click
       handler.

       Tick marks are simply labels, and are not clickable.


       All entries have what I refer to as a unified year associated with
       them.  The unified year runs from zero for the date AM 0, and
       increases monotonically all the way up to the last event (at 90 AD).
       It takes care of the place where dates swap from AM to BC, and the
       values are arranged to mirror the chronological interval between
       events.  This means they can be used for ordering and positioning.

       In addition, AnnotatedYear items can be given a human-readable date
       drawn from one of a collection of alternative chronologies.  The
       particular chronology used for this is user-selectable at run time.
       
       We now come on to the matter of vertical positioning.  To a first
       approximation, we want to position each event proportionate to its
       unified year.  If it were actually that simple, 'all' we would need
       to do is decide how much vertical space to assign to every year
       from about 4004 BC to about 100 AD, based upon the font size
       currently in use, along with a little additional inter-line spacing
       to improve readability, and then position things according to
       their offset year.

       Needless to say, though, it's _not_ that simple ...

       Over the AM period, events tend to be very sparse, and we would
       therefore end up with large chunks of timeline which were totally
       empty (but for tick marks).  We therefore split the timeline
       notionally into two parts -- the AM portion, where we assign very
       little vertical space per year, and the BC/AD portion, where we
       assign rather more.

       This notwithstanding, it is possible to end up with consecutive
       events which are so close together in time that positioning them
       to reflect their date would cause them to overlap.  Here I simply
       shift the later ones enough to avoid overlap, and accept that this
       will result in something where some of the dates are not actually
       proportionately spaced.

       The overall approach relies upon the ordering of the incoming
       data, which is by unified year, except that where several events
       carry the same unified year, the AnnotatedYear entry comes first,
       then any chapter entry, and then duration starts and ends.
    */
    
    _lastUnifiedYearInAm = -1;    // The unified year for the last event which falls into the AM portion.
    _lastPosInAm = -1;            // The position of the last visible event which falls into the AM portion.

    _renderYears ()
    {
	/**********************************************************************/
	/* Determine font size dynamically.  This is assumes that if we want
	   to follow user preferences, --defaultfont is indeed updated
	   elsewhere in line with any changes the user may make. */
	
	const fontSizeInPx = parseFloat(_ClassCommon.getVariableSetting('--defaultFontSize'));


	
	/**********************************************************************/
	this._deleteAndRecreateWorkingElements()
	this._sortOutMutualScrolling();



	
	/**********************************************************************/
	/* Determine what's going in the 'Other' column, and reflect this in
	   the header. */
	
	const selectedAltChronology = _ClassAlternativeChronologies.makeChronologyKeyFromCache();
	_ClassAlternativeChronologies.displayActiveAlternativeChronologyName(selectedAltChronology);

	

	/**********************************************************************/
	/* Maps between key values and the div which represents them.  Start
	   off by emptying the map (obviously not necessary if the present
	   method is only ever called once, but in fact it may be called on
	   screen resize). */
	
	JChronologyData.clearKeyToElementsMapping();
	_ClassCommon.resetRootResolver();


	
	/**********************************************************************/
	/* The AM events and the BC / AD events are subject to different
	   spacing regimes, so it's convenient to split them into two separate
	   lists. */
	
	function isAmEvent (event) { return JChronologyData.getUnifiedYear(event) <= JChronologyData.getLastUyearInAm(); }

	const [amEvents, bcAdEvents] = 
	      JChronologyData.getEntries()
	        .reduce(
		  ([pass, fail], elem) => {
		      return isAmEvent(elem)
			  ? [[...pass, elem], fail]
			  : [pass, [...fail, elem]];
		  },
		  [[], []]
	      );
    

	
	/**********************************************************************/
	/* We have two date columns, and want them to be aligned as though
	   they were in a table, even though they are not.  To this end, we
	   need to pad the right-hand date to a fixed width. */
	
	function padDate (s)
	{
	    const paddingNeeded = 7 - s.length;
	    return '&nbsp;'.repeat(paddingNeeded) + s;
	}


	
	/**********************************************************************/
	var mostRecentUnifiedYear = -1;
	var mostRecentPos = -1;
	const durationMap = new Map();
	var rawPositionFunction = null;
	const descriptionDivs = [];
	var associatedChapterIx = -1;



	/**********************************************************************/
        const doYear = (e, type) =>
	{
	    /******************************************************************/
	    const isChapterEntry = JChronologyData.isChapterEntry(e); // A pseudo event assocated with the start of a chapter.
	    const isAnnotatedYearEntry = JChronologyData.isAnnotatedYearEntry(e);
	    const isVisibleEntry = !JChronologyData.isDurEntry(e);
	    const flags = isVisibleEntry ? JChronologyData.getFlags(e) : ''; // Tells us whether this is an approximate date, etc.
	    const key = JChronologyData.getKey(e);
	    const sameYearAsPrevious = mostRecentUnifiedYear == JChronologyData.getUnifiedYear(e);
	    const divList = [null, null, null, null]; // The divs associated with this event.



	    /******************************************************************/
	    /* Work out where to put the tag ...

	       If this is an entry which the user will see on the
	       timeline, try positioning it as would be dictated by
	       the date of the event within the overall chronology.
	       If that would overlap with the most recent tag, move it
	       down a bit.  And either way, record the position so
	       that we can check for overlaps next time round.  We
	       also record the year offset for use with
	       duration processing. */

	    var pos = -1;
	    
	    if (isVisibleEntry)
	    {
		mostRecentUnifiedYear = JChronologyData.getUnifiedYear(e);
		pos = rawPositionFunction(mostRecentUnifiedYear);
		pos = Math.max(pos, mostRecentPos + _ClassCommon.getVerticalSpaceForDatesMinimumToAvoidOverlap());
		mostRecentPos = pos;
		if (sameYearAsPrevious) mostRecentPos += this._additionalSpacingAfterSameYearAsPrevious;
	    }



	    /******************************************************************/
	    /* Duration tags are different.  I do create them, because they
	       are useful to make the start and end of duration lines, such
	       that the positions can be readily updated with screen
	       resizing etc.  But they are invisible, and there is therefore
	       no problem if they overlap things -- and also the presence
	       of a duration tag does not get in the way of event tags.

	       So to get the easy bit out of the way first ... we _do_
	       need to work out a position, but we don't need to update
	       mostRecentUnifiedYear or mostRecentPos, because what we are
	       doing here is essentially invisible to the processing for
	       'real' events.

	       As regards the position, because the chronology data is
	       ordered by offset year, and further ordered so that if a
	       duration event shares the same date as a visible event, the
	       duration event always comes later in the ordering, we can
	       simply take the larger of the position given by the raw
	       chronology-based calculation and the most recent event
	       position. */

	    else // A duration tag.
	    {
		const unifiedYear = JChronologyData.getUnifiedYear(e);
		pos = Math.max(rawPositionFunction(unifiedYear), mostRecentPos);
		pos += fontSizeInPx / 2; // Positions the top of the duration by the vertical mid point of the text which describes it.
	    }



	    /******************************************************************/
	    /* We have an 'Other' entry if this is a visible non-chapter
	       entry. */

	    if (isVisibleEntry && !isChapterEntry)
	    {
		const div = document.createElement('div');
		div.classList.add('jchronologyTimelineElement');
		div.classList.add('jchronologyOtherDateElement');
		div.addEventListener('click', () => JEventHandlers.eventClickHandler(div));
		div.setAttribute('data-key', key);
		div.style.top = pos + 'px';
		_ClassCommon.getVerticalDiv('jchronologyOtherDates').appendChild(div);
		div.innerHTML = JChronologyData.getField(e, selectedAltChronology);
		divList[0] = div;
	    }

	    
		
	    /******************************************************************/
	    /* We have a 'Modern' entry if this is a visible entry.  Strictly
	       we have the necessary data to be able to give a date even on a
	       pure chapter entry, but we don't trust those dates. */

	    if (isVisibleEntry && !isChapterEntry)
	    {
		const div = document.createElement('div');
		div.classList.add('jchronologyTimelineElement');
		div.classList.add('jchronologyModernDateElement');
		div.addEventListener('click', () => JEventHandlers.eventClickHandler(div));
		div.setAttribute('data-key', key);
		div.style.top = pos + 'px';
		_ClassCommon.getVerticalDiv('jchronologyModernDates').appendChild(div);
		div.innerHTML = '&nbsp;' + padDate(JChronologyData.getAnnotatedYearModernDate(e));
		divList[1] = div;
	    }


		
	    /******************************************************************/
	    /* Create the marker which goes on the timeline. */
	    
	    if (isVisibleEntry)
	    {
		const div = document.createElement('div');
		div.classList.add('jchronologyYearMarkerCircle');
		_ClassCommon.getVerticalDiv('jchronologyTimelineHolder').appendChild(div);
		div.setAttribute('data-key', key);
		div.style.top = pos + 'px';
		div.addEventListener('click', () => JEventHandlers.eventClickHandler(div));
		divList[2] = div;
	    }




	    /******************************************************************/
	    /* We also have a 'Year description' entry for anything which is
	       visible.

	       As regards content, if this is a pure chapter event, things are
	       relatively easy -- we just want to convert it to 'pretty' form.

	       If this is a vanilla event, it's more complicated.  We want the
	       standard content, devoid of links.  But if there is an
	       associated chapter entry, we want the content from it to0. */

	    if (isVisibleEntry)
	    {
		/**************************************************************/
		const div = document.createElement('div');
		div.classList.add('jchronologyTimelineElement');
		div.classList.add(isChapterEntry ?  'jchronologyChapterEventDescription' : 'jchronologyYearDescription');
		div.addEventListener('click', () => JEventHandlers.eventClickHandler(div));
		div.setAttribute('data-key', key);
		div.style.top = pos + 'px';
		_ClassCommon.getVerticalDiv('jchronologyYearDescriptions').firstElementChild.firstElementChild.appendChild(div);
		divList[3] = div;


		/**************************************************************/
		var content = '';

		if (isChapterEntry)
		    content = '<span class="iconFont">K&nbsp;</span>' + this._convertToRanges(JChronologyData.getChapterRefs(e));
		else if (isAnnotatedYearEntry)
		{		
		    content = JChronologyData.withoutLinks(JChronologyData.getDescription(e)); // We don't want person and place links in the event description.  They will be available
		                                                                               // in the info-box, and in the event description they'll get in the way of click handling.
		    var scriptureRefs = JChronologyData.getChaptersFromChapterAndYearDataAsString(e);
		    if ('' != scriptureRefs)
		    {
			scriptureRefs = this._convertToRanges(scriptureRefs);
			content += '&nbsp;&nbsp;<span class="iconFont">K&nbsp;</span>' + scriptureRefs;
		    }
		}

		div.innerHTML = _ClassJChronologyUtilities.withDurationColours(content);
		div.style.width = _ClassCommon.getVerticalDiv('jchronologyYearDescriptions').scrollWidth + "px";

		descriptionDivs.push(div);
	    }


	    
	    /******************************************************************/
	    /* A non-visible event is a duration.  We need to record the fact
	       by way of class settings. */
	    
	    if (!isVisibleEntry)
	    {
		const div = document.createElement('div');
		div.classList.add('jchronologyDurationElement');
		div.setAttribute('data-key', key);
		div.style.top = pos + 'px';
		_ClassCommon.getVerticalDiv('jchronologyDurationLines').appendChild(div);

		if (JChronologyData.isDurStartEntry(e))
		    durationMap.set(JChronologyData.getKey(e), div) // Temporarily this maps the key of the duration-start to the hidden div which marks the start.
		else
		{
		    const key = JChronologyData.convertDurationEndKeyToStartKey(JChronologyData.getKey(e));
		    const start = durationMap.get(key);
		    durationMap.set(key, [start, div]); // This now replaces the temporary entry with one which maps the key of the duration-start to the pair of hidden divs which mark the start and end.
		}
	    }



	    /******************************************************************/
	    JChronologyData.recordElementsForKey(key, divList);
	} // doYear


	
	/**********************************************************************/
	/* Deal first with the 'AM' events.  The raw position of these is
	   reasonably easy, because AM simply runs forward from 0, so the
	   position is determined by leaving a bit of a gap for the header,
	   and then just converting the unified year proportionately to a
	   number of pixels.  (This initial raw position may then be adjsted
	   to avoid overlaps.) */
	
	rawPositionFunction = this.rawPositionForAmDate.bind(this);
	for (const e of amEvents)
	    doYear(e, 'AM')



	/**********************************************************************/
	/* This makes it possible to have a different spacing for BC events,
	   on the grounds that in the main they are rather closer together.
	   Whether this helps is, perhaps, dubious.  If you make them far
	   enough apart to reduce the number of overlaps (and therefore to
	   make the spacing more proportionate), you end up with some huge
	   gaps. */

	this._lastPosInAm = mostRecentPos;
	this._lastUnifiedYearInAm = mostRecentUnifiedYear;
	rawPositionFunction = this.rawPositionForNonAmDate.bind(this);
	for (const e of bcAdEvents)
	    doYear(e, 'BCAD')
	
	

	/**********************************************************************/
	/* We've built things up outside of the document.  Time to remedy 
	   that. */
	    
	const parent = _ClassCommon.getColumnsContainer();
	_ClassCommon.getVerticalDivIds().forEach ( id => {
	    parent.appendChild(_ClassCommon.getVerticalDiv(id));
	});


	    
	/**********************************************************************/
	/* You have to have added the elements to the DOM, as per the
	   previous code para, before you can call this. */
	
	this._addTickMarks();


	
	/**********************************************************************/
	/* Add a pseudo marker which can be used when invoked with a date which
	   doesn't feature in the list of events. */
	
	const marker = document.createElement('div');
	marker.classList.add('jchronologyYearMarkerDiamond', 'jchronologyYearMarkerHighlight');
	marker.style.display = 'none';
	_ClassCommon.setArbitraryDateMarker(marker);
	_ClassCommon.getDurationLinesContainer().appendChild(marker);
	_JChronologyPresentationHandler.reselectNonAnnotatedYear();



	/**********************************************************************/
	return durationMap;
    } // renderYears


    /**************************************************************************/
    /* The bottom part of the screen consists of various rows and columns
       with special issues as regards scrolling ...

       We need the duration header to scroll horizontally in sync with the
       divs which make up the main body of the display (and vice-versa: if
       we scroll those divs, we need to scroll the duration header).

       We need the divs in the main body to scroll as though they were one
       wide div, even though they aren't.

       We need the divs in the main body to scroll vertically in sync, but
       we want a scroll bar only on the rightmost.

       And we need all this to work on touchscreens too. */
    
    _sortOutMutualScrolling ()
    {
	/**********************************************************************/
	/* We want the overflow header and the main content container to scroll
	   horizontally in sync, with either driving the other.  Note that
	   only the main container has a horizontal scroll bar. */
	
	const scrollA = document.getElementById('jchronologyDurationHeaders');
	const scrollB = _ClassCommon.getColumnsContainer();

	var isSyncing = false;

	function syncScroll(source, target)
	{
	    if (isSyncing) return;
	    isSyncing = true;

	    requestAnimationFrame(() => {
		target.scrollLeft = source.scrollLeft;
		isSyncing = false;
	    });
	}

	scrollB.addEventListener("scroll", () => {
	    syncScroll(scrollB, scrollA);
	});

	scrollA.addEventListener("scroll", () => {
	    syncScroll(scrollA, scrollB);
	});


	
	/**********************************************************************/
	/* This was needed where we wanted just one of the columns to scroll.
	   I'm reluctant to ditch in case we want to go back to that.
	   However, as things stand, the parent container deals with all the
	   scrolling, so we don't need the code here. */
	
	return;



	/**********************************************************************/
	const cols = _ClassCommon.getVerticalDivs();
	const allButRightCol = cols.slice(0, -1);
	const rightCol = cols.at(-1);



	/**********************************************************************/
	function syncScrollVertical (y)
	{
	    cols.forEach(c => c.scrollTop = y);
	}

	

	/**********************************************************************/
	/* When the right column scrolls vertically, sync the others. */

	rightCol.addEventListener('scroll', () => {
	    const y = rightCol.scrollTop;
	    syncScrollVertical(y);
	});



	/**********************************************************************/
	/* On a touch screen, things are more complicated, because we want
	   scrolling to work on any of the columns. */

	cols.forEach(c => {
	    if (c !== rightCol)
	    {
		c.addEventListener("wheel", e => {
		    rightCol.scrollTop += e.deltaY;
		    syncScrollVertical(rightCol.scrollTop);
		    e.preventDefault();
		});


		var startY;
		c.addEventListener("touchstart", e => {
		    startY = e.touches[0].clientY;
		});
		c.addEventListener("touchmove", e => {
		    const dy = startY - e.touches[0].clientY;
		    rightCol.scrollTop += dy;
		    syncScrollVertical(rightCol.scrollTop); // update all columns
		    startY = e.touches[0].clientY;
		    e.preventDefault();
		}, { passive: false });
	    }
	});
    }


    /**************************************************************************/
    /* This is used when displaying, on the timeline, details of the
       chapters which refer to events in a given year.  We often have
       several consecutive chapters, and rather than display each
       individually, I convert them to ranges. */
    
    _convertToRanges (input)
    {
	/*********************************************************************/
	/* Get the input into common form.  The input is assumed either to be
	   a string of references of the form Gen.1; Gen.2; Rev.1 ... or else
	   a list of two-element lists, where the first part of each
	   each two-element list is a reference. */
	
	if ('string' === typeof input)
	    input = input.split('; ');
	else
	    input = input.map(sublist => sublist[0]);

	const items = input
	      .map(s => {
		  const [prefix, numStr] = s.split('.');
		  return { prefix, num: parseInt(numStr, 10) };
	      });



	/*********************************************************************/
	/* Note that '<=' in the for loop below really _is_ intended.  If we
	   run off the end of items, cur comes back as undefined, and the
	   code is set up to accept this and deal correctly with the end
	   condition. */
	
	const result = [];
	var start = items[0];
	var last = items[0];

	for (var i = 1; i <= items.length; i++)
	{
	    const cur = items[i];
	    if (cur   &&   cur.prefix === last.prefix   &&   cur.num === last.num + 1)
	    {
		last = cur; // Still in the same sequential run.
		continue;
	    }

	    if (start.num === last.num)
		result.push(`${start.prefix}.${start.num}`);
	    else
		result.push(`${start.prefix}.${start.num}-${last.num}`);
		
	    start = cur;
	    last = cur;
	}

	return result.join('; ');		
    }


    /**************************************************************************/
    /* The individual dates, year descriptions, etc are held in four
       elements, one for other dates, one for modern dates, and one for
       year descriptions.

       It turns out to be very much quicker if we create these elements
       outside of the document, then add everything to them, and only then
       place the two elements within the document.  (Quicker by a factor of
       almost five.) */

    _deleteAndRecreateWorkingElements ()
    {
	/**********************************************************************/
	/* The columns containers. */
	
	function deleteAndRecreateContainer (id)
	{
	    document.getElementById(id)?.remove();
	    const div = document.createElement('div');
	    div.classList.add('jchronologyBodyColumn');
	    div.id = id;
	    return { id: id, div: div };
	}

	_ClassCommon.setVerticalDivs(_ClassCommon.getVerticalDivIds().map(deleteAndRecreateContainer));



	/**********************************************************************/
	/* Rather pointless, but unless I put the year descriptions inside
	   these, the container doesn't get to find out the full width,
	   and therefore doesn't scroll properly. */
	
	const wrapper = document.createElement('div'); wrapper.classList.add('jchronologyAbsoluteWrapper');
	const content = document.createElement('div'); content.classList.add('jchronologyAbsoluteContent');
	wrapper.appendChild(content);
	_ClassCommon.getVerticalDiv('jchronologyYearDescriptions').appendChild(wrapper);



	/**********************************************************************/
	/* The timeline. */

	const timelineId = 'jchronologyTimeline';
	document.getElementById(timelineId)?.remove();
	const div = document.createElement('div');
	div.id = timelineId;
	_ClassCommon.getVerticalDiv('jchronologyTimelineHolder').appendChild(div);



	/**********************************************************************/
	/* A marker which can be used to highlight selected items. */

	const selectedItemHighlighter = document.createElement('div');
	selectedItemHighlighter.id = 'jchronologySelectedItemHighlighter';
	_ClassCommon.getVerticalDiv('jchronologySelectedItemHighlighterHolder').appendChild(selectedItemHighlighter);
	_ClassCommon.setSelectedItemHighlighter(selectedItemHighlighter);
    }
}

const JRenderer = new _ClassJRenderer();




/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                            Controls and menus                            **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                             Click handler                                **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
class _ClassJEventHandlers
{
    /**************************************************************************/
    /* No need to restore settings to the way they stood on entry to the
       pop-up.  See _ClassAlternativeChronologies. */
     
   alternativeChronologiesSelectorCancel (event)
    {
	this.hideDateHelp();
    }


    /**************************************************************************/
    alternativeChronologiesSelectorOk ()
    {
	if (document.getElementById('ussherCheckbox').checked)
	    _ClassAlternativeChronologies.selectUssher();
	else
	    _ClassAlternativeChronologies.selectOther();
	this.hideDateHelp();
    }

    
    /**************************************************************************/
    /* Selects a plain vanilla or chapter event on the timeline. */
    
    eventClickHandler (eventDiv)
    {
	_JChronologyPresentationHandler.selectAnnotatedYear(eventDiv, false);
    }

    
    /**************************************************************************/
    handleLink (event)
    {
	const tag = event.target;
	switch (tag.getAttribute('data-type'))
	{
	    case 'L': { JFrameworkStepDataAccessors.strongLinkToMap      (tag); break; }
	    case 'P': { JFrameworkStepDataAccessors.strongLinkToGenealogy(tag); break; }
	    case 'S': { _JChronologyPresentationHandler.setScriptureWindowContent(tag.dataset.ref, true); break; }
	}
    }


    /**************************************************************************/
    hideDateHelp ()
    {
	const modal = document.getElementById('dateHelp');
	ModalDialogHandler.closeIfTopModalDialog(modal);
    }


    /**************************************************************************/
    hideWelcomeDialog ()
    {
	ModalDialogHandler.closeIfTopModalDialog(document.getElementById('welcomeDialog'));
    }

    
    /**************************************************************************/
    /* Note that we need a copy of the settings as they stand on entry in case
       the user hits Cancel.  However, there is no need to have a copy within
       program memory, because the settings are based upon the localStorage
       collection, and it is this which we keep up to date and use for
       defaulting. */
    
    showDateHelp ()
    {
	_ClassAlternativeChronologies.init();
	const modal = document.getElementById('dateHelp');
	ModalDialogHandler.showModalDialog(modal);
	const ussherCheckbox = document.getElementById('ussherCheckbox');
	this._ussherCheckboxSettingOnEntry = ussherCheckbox.checked; // In case the user hits cancel.
	this.ussherCheckboxToggled(ussherCheckbox);
	modal.querySelector('.jframework-modalDialogBody').scrollTop = 0;
	modal.style.top = '20px';
	modal.style.left = (window.innerWidth - modal.offsetWidth) / 2 + 'px';
    }

  
    /**************************************************************************/
    showHelpMenu ()
    {
	const modal = document.getElementById('help');
	ModalDialogHandler.showModalDialog(modal);
	modal.querySelector('.jframework-modalDialogBody').scrollTop = 0;
	modal.style.top = '20px';
	modal.style.left = (window.innerWidth - modal.offsetWidth) / 2 + 'px';
	modal.scrollTop = 0;
    }

  
    /**************************************************************************/
    showLayoutMenu ()
    {
	const modal = document.getElementById('layoutMenu')

	ModalDialogHandler.showModalDialog(modal);

	modal.style.top = '20px';
	modal.style.left = (window.innerWidth - modal.offsetWidth) / 2 + 'px';

	document.getElementById('horizontalSpacingSlider').value = CurrentHorizontalSpacingTicks;
	document.getElementById('verticalSpacingSlider').value = CurrentVerticalSpacingTicks;
	document.getElementById('numberOfGenerationsSlider').value = CurrentNumberOfGenerationsToGrowByOnEachExpansion;
    }


    /**************************************************************************/
    showWelcome ()
    {
	this.showHelpMenu();
    }

  
    /**************************************************************************/
    updateScriptureWindow (tag)
    {
	_JChronologyPresentationHandler.setScriptureWindowContent(tag.textContent.replace('?', ''), true);
    }

    
    /**************************************************************************/
    ussherCheckboxToggled (checkbox)
    {
	if (checkbox.checked)
	    document.getElementById('modernChronologySelector').classList.add('disabledElementAndContents');
	else
	    document.getElementById('modernChronologySelector').classList.remove('disabledElementAndContents');
    }
}

export const JEventHandlers = new _ClassJEventHandlers();
window.JEventHandlers = JEventHandlers;




    
/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                           Presentation handler                           **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/* Settings are held in local storge, with defaults as defined by _getDflt.
*/

/******************************************************************************/
class _ClassAlternativeChronologies
{
    /**************************************************************************/
    static _existingChronologyKey = '';


    /**************************************************************************/
    /* A human-readable string describing the alernative chronology currently
       being displayed. */
    
    static displayActiveAlternativeChronologyName (chronologyName)
    {
	var s = chronologyName.replace('dt_', '');
	if (s.includes('_'))
	{
	    var x = s.split('_');
	    x[0] = x[0] + ' dates'
	    x[1] = 'Egypt yrs: ' + x[1];
	    x[2] = 'Exodus C' + x[2] + ' BC';
	    s = x.join('<br>');
	}
	
	document.getElementById('activeAlternativeChronologyName').innerHTML = s;
    }

    
    /**************************************************************************/
    static init ()
    {
	this._initRadioButtonsInChronologySelector();
	// this._setDateColumnsToReflectLocalStorageOnEntry.
    }


    /**************************************************************************/
    /* This takes the cached values and creates a key made up of 'dt_'
       followed by other elements to reflect what we're supposed to be
       displaying.  This is used elsewhere to determine how to populate the
       column. */
    
    static makeChronologyKeyFromCache ()
    {
	if ('y' == this._getValueFromCache('Ussher'))
	    return 'dt_Ussher';
	else
	    return 'dt_' + this._getValueFromCache('DateCategory') + '_' + this._getValueFromCache('YearsInEgypt') + '_' + this._getValueFromCache('ExodusDate');
    }

    
    /**************************************************************************/
    /* Arranges to display, as the alternative chronology, something other
       than Ussher. */
    
    static selectOther ()
    {
	this._saveRadioButtonsToCache();
	localStorage.setItem('chronologyUssher', 'n');
	const chronologyKey = this.makeChronologyKeyFromCache();
	this._updateDateColumn(chronologyKey);
    }


    /**************************************************************************/
    /* Arranges to display Ussher as the alternative chronology. */
    
    static selectUssher ()
    {
	localStorage.setItem('chronologyUssher', 'y');
	this._updateDateColumn('dt_Ussher');
    }

    
    /**************************************************************************/
    static _getDflt (cacheKey)
    {
	switch (cacheKey)
	{
	    case 'DateCategory': return 'Hebrew';
	    case 'YearsInEgypt': return '400';
	    case 'ExodusDate'  : return '15';
	    case 'Ussher'      : return 'y';
	}
    }

    
    /**************************************************************************/
    static _getRadioButtonValue (cacheKey)
    {
	return document.querySelector(`input[name='${cacheKey}']:checked`).value;
    }


    /**************************************************************************/
    static _getValueFromCache (cacheKey)
    {
	return localStorage.getItem(`chronology${cacheKey}`) ?? this._getDflt(cacheKey);
    }


    /**************************************************************************/
    /* Sets the buttons and checkbox in the modal used to select alternative
       chronologies to reflect the cache settings. */
    
    static _initRadioButtonsInChronologySelector ()
    {
	const me = this;
	function setRadioButtonsFromCache (cacheKey)
	{
	    const cacheValue = me._getValueFromCache(cacheKey);
	    const radio = document.querySelector(`input[type='radio'][name='${cacheKey}'][value='${cacheValue}']`);
            radio.checked = true;
	}
	    
	setRadioButtonsFromCache('DateCategory');
	setRadioButtonsFromCache('YearsInEgypt');
	setRadioButtonsFromCache('ExodusDate');

	const ussherSetting = me._getValueFromCache('Ussher');
	document.getElementById('ussherCheckbox').checked = 'y' == ussherSetting.toLowerCase();
    }


    /**************************************************************************/
    static _saveRadioButtonsToCache ()
    {
	const me = this;
	function setCacheFromRadioButtons (buttonKey)
	{
	    localStorage.setItem('chronology' + buttonKey, me._getRadioButtonValue(buttonKey));
	}

	setCacheFromRadioButtons('DateCategory');
	setCacheFromRadioButtons('YearsInEgypt');
	setCacheFromRadioButtons('ExodusDate');

	localStorage.setItem('chronologyUssher', document.getElementById('ussherCheckbox').checked ? 'y' : 'n');
    }


    /**************************************************************************/
    /* Sets the alternative date column to hold the relevant chronology. */
    
    static _updateDateColumn (chronologyKey)
    {
	this.displayActiveAlternativeChronologyName(chronologyKey);
	
	const tags = document.getElementsByClassName('jchronologyDateAlternative');
	for (const tag of tags)
	{
	    const key = tag.getAttribute('data-key');
	    if (!key) continue;
	    const revisedContent = JChronologyData.getField(JChronologyData.getEntryGivenKey(key), chronologyKey);
	    tag.innerHTML = revisedContent;
	}
	
	JRenderer.adjustDimensionsAndPositions(true);
    }
}





/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                           Presentation handler                           **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
class _ClassJChronologyPresentationHandler
{
    /**************************************************************************/
    _preferredYearRepresentation = 'Modern';
    preferredYearIsModern () { return 'M' == this._preferredYearRepresentation[0]; }
    preferredYearIsUssher () { return 'U' == this._preferredYearRepresentation[0]; }

    
    /**************************************************************************/
    _selectedEventDiv = null;
    _selectedEventYear = null;
    _selectedNonAnnotatedYearPos = null;
    
    

    /**************************************************************************/
    /* Mainly intended for things like resizing, when we may end up doing a
       fair bit of redrawing, and may want to ensure that the original event
       is still selected. */
    
    reselectAnnotatedOrNonAnnotatedYear ()
    {
	if (null !== this._selectedEventDiv)
	    this.selectAnnotatedYear(this._selectedEventDiv);
	else
	    this.reselectNonAnnotatedYear();
    }
    
    
    /**************************************************************************/
    reselectNonAnnotatedYear ()
    {
	if (null !== this._selectedNonAnnotatedYearPos)
	    this.selectNonAnnotatedYear(this._selectedNonAnnotatedYearPos);
    }

    
    /**************************************************************************/
    /* Updates info box, highlighting, etc, when a new selection is made. */
    
    selectAnnotatedYear (eventDiv, centreSelection = true)
    {
	/**********************************************************************/
	/* Make sure we aren't showing the special marker we use for years
	   which have no associated data. */
	
	_ClassCommon.getArbitraryDateMarker().style.display = 'none';


	
	/**********************************************************************/
	/* Deal with the side-effects of the selection -- updating the info
	   box and the scripture window. */
	
	const entry = JChronologyData.getEntryGivenElement(eventDiv);
	const isChapterEntry = JChronologyData.isChapterEntry(entry);
	
	if (isChapterEntry)
	{
	    const refs = JChronologyData.getChapterRefsAsString(entry);
	    this.setScriptureWindowContent(refs.split('; ')[0], false);
	    this._setInfoBoxContentForChapterEvent(entry);
	}
	else
	{
	    this.setScriptureWindowContent(JChronologyData.getAnnotatedYearScriptureRefs(entry), false);
	    this._setInfoBoxContentForStandardEvent(entry);
	}
	


	/**********************************************************************/
	/* At the time of writing, we change the colour of the selected marker,
	   and we position a highlighting bar, both of them marking the
	   selection.

	   Note that we need to turn off any previous highlighting of the
	   marker, or we'll end up with two things being highlighted.  But
	   we don't need to hide the bar, because we're always going to have
	   one _somewhere_: it's just a case of moving it to the correct
	   position. */
	
	const newKey = JChronologyData.getKey(entry);
	const thisMarker = JChronologyData.getMarkerGivenKey(newKey);

	const oldKey = null === this._selectedEventDiv ? null : this._selectedEventDiv.getAttribute('data-key');
	const oldMarker = null === oldKey ? null : JChronologyData.getMarkerGivenKey(oldKey);

	if (null !== oldKey)
	    oldMarker.classList.remove('jchronologyYearMarkerHighlight');

	thisMarker.classList.add('jchronologyYearMarkerHighlight');
	this._positionSelectionHighlightMarker(eventDiv);
	
	this._selectedEventDiv = eventDiv;
	this._selectedEventYear = JChronologyData.getAnnotatedYearModernDate(entry).replace(' ', '');


	/**********************************************************************/
	if (centreSelection)
	    JFrameworkUtils.centrePointVerticallyWithinScrollingContainer(_ClassCommon.getVerticalDiv('jchronologyYearDescriptions').parentElement, this._selectedEventDiv.style.top);

	// $$$ JRenderer.doDurationHeaders();
    }


    /**************************************************************************/
    _positionSelectionHighlightMarker (eventDiv)
    {
	const highlighter = _ClassCommon.getSelectedItemHighlighter();
	const eventRect = eventDiv.getBoundingClientRect();
	const containerRect = _ClassCommon.getContentContainer().getBoundingClientRect();
	highlighter.style.height = eventRect.height + 'px';
	highlighter.style.top = (eventRect.top - containerRect.top) + 'px';
	highlighter.style.width = containerRect.width + 'px';
    }	


    /**************************************************************************/
    selectNonAnnotatedYear (pos)
    {
	this._selectedEventDiv = null;
	this._selectedNonAnnotatedYearPos = pos;
	const marker = _ClassCommon.getArbitraryDateMarker();
	marker.style.top = pos + 'px';
	marker.style.display = 'block';
	this._positionSelectionHighlightMarker(marker);
	JFrameworkUtils.centrePointVerticallyWithinScrollingContainer(_ClassCommon.getVerticalDiv('jchronologyYearDescriptions').parentElement, marker.style.top);
	// $$$ JRenderer.doDurationHeaders();
    }


    /**************************************************************************/
    setScriptureWindowContent (scriptures, forceScripturePaneVisible)
    {
	if ('' === scriptures) return;
	JFrameworkMultiframeCommunicationsSlave.sendSetUrlForce('scripture', window.location.origin + '/?skipwelcome&q=' + 'reference=' + scriptures + '&options=VHN&noredirect');

	if (forceScripturePaneVisible)
	    JChronology.sendMessageTo('scripture', { forceTabVisible: 'scripture' }, 'chronology');
    }


    /**************************************************************************/
    _copyLinkToClipboard ()
    {
	const entry = JChronologyData.getEntryGivenElement(this._selectedEventDiv);
	const key = JChronologyData.getKey(entry);
	const type = key.startsWith('EC') ? '&type=chapter' : '&type=event';
	const url = JFrameworkUtils.getFullUrl('html/J_AppsHtml/J_Chronology/j_chronologySplit3.html?year=' + this._selectedEventYear + type);
	navigator.clipboard.writeText(url);
	this._showPopUp('URL copied to clipboard', 'copyToClipboardConfirmation');
    }

	

    /**************************************************************************/
    /* Returns the info box with lazy evaluation. */
    
    _getInfoBox ()
    {
	if (!this.hasOwnProperty('_infoBox'))
	    this._infoBox = document.getElementById('info-box');
	return this._infoBox;
    }

    
    /**************************************************************************/
    /* Fills the info box for a pseudo event which represents a collection of
       sceripture dates associated with the given chapter. */
    
    _setInfoBoxContentForChapterEvent (entry, initialContent = '')
    {
	/**********************************************************************/
	const infoBox = this._getInfoBox();
	const date = ''; // '<br><b>' + JChronologyData.getAnnotatedYearModernDate(entry) + ':</b> ';
	const refs = JChronologyData.getChapterRefsAsString(entry);
	const caveatsA = refs.includes('?') ? ' (Question marks against references highlight chapters whose dates are particularly open to debate.)' : '';


	
	/**********************************************************************/
	(async () => {
	    var content = initialContent + '<br>'; // date + intro + '<br><br>';
	    for (const chapterRef of refs.split('; '))
	    {
		const link = _ClassJChronologyUtilities.withChapterScriptureLinks(chapterRef);
		var associatedText = await JFrameworkChapterSummaries.instance().getChapterSummary(chapterRef);
		if (!associatedText) associatedText = '&mdash;';
		associatedText = JChronologyData.withLinks(associatedText);
		//associatedText = '<p>' + link + ': ' + associatedText.replaceAll('', '</p><p class="indentedPara">') + '</p><br>';
		associatedText = '<p>' + link + ': ' + associatedText + '</p><br>';
		content += associatedText;
	    }

	    content = content.slice(0, -4);

	    infoBox.innerHTML =
		`<div style='display:flex; align-items:center'>
                  <span id='shareableLink' class='jframework-linkAsButton' style='margin-left:auto' title='Copy to clipboard a URL for this event'>Shareable link</span>
                </div>
                ${content}`;
	})();
	


	/**********************************************************************/
	infoBox.querySelector('#shareableLink').addEventListener('click', () => this._copyLinkToClipboard());



	/**********************************************************************/
	infoBox.scrollTop = 0;
    }
    

    /**************************************************************************/
    /* Does what it says on the tin. */
    
    _setInfoBoxContentForStandardEvent (entry)
    {
	const infoBox = this._getInfoBox();
	const date = JChronologyData.getAnnotatedYearModernDate(entry);
	const shortDescription = JChronologyData.withLinks(JChronologyData.getDescription(entry));
	const scriptures = JChronologyData.getAnnotatedYearScriptureRefs(entry);
	const extraBiblicalRefs = JChronologyData.getAnnotatedYearNonScriptureRefs(entry);
	const longDescription = JChronologyData.getAnnotatedYearArticle(entry);

	var caveatsA = '';
	var caveatsB = '';
	if (JChronologyData.getFlags(entry).includes('~')) caveatsA = 'Date is approximate.';
	if (JChronologyData.getFlags(entry).includes('*')) caveatsB = 'This event is one of a collection which different chronologies place in different orders.';

	if ('' !== caveatsA && '' !== caveatsB) caveatsA += '<br>';
	caveatsA += caveatsB;
	if ('' !== caveatsA) caveatsA = '<br><br>' + caveatsA;

	(async () => {
	    var chapterSummaries = '';
	    const chaptersFromChapterAndYearData = JChronologyData.getChaptersFromChapterAndYearData(entry);
	    for (const chapterThunk of chaptersFromChapterAndYearData)
	    {
		const link = _ClassJChronologyUtilities.withChapterScriptureLinks(chapterThunk.ref);
		var associatedText = await JFrameworkChapterSummaries.instance().getChapterSummary(chapterThunk.ref);
		if (!associatedText) continue;
		associatedText = JChronologyData.withLinks(associatedText);
		associatedText = '<p>' + link + ': ' + associatedText.replaceAll('', '</p><p class="indentedPara">') + '</p><br>';
		chapterSummaries += associatedText;
	    }
	    

	    var content = '<b>' + date + ': ' + shortDescription + (shortDescription.endsWith('.') ? '' : '.') + '</b>' + caveatsA + '<br><br>';
	    if ('' != scriptures) content += '<b>Scripture references:</b> ' + scriptures + '<br><br>';
	    if ('' != extraBiblicalRefs) content += '<b>External references:</b> ' + extraBiblicalRefs + '<br><br>';
	    content += longDescription;
	    content += (chapterSummaries == '' ? '' : '<br><br>') + chapterSummaries;

	    infoBox.innerHTML =
		`<div style='display:flex; align-items:center'>
                  <span id='shareableLink' class='jframework-linkAsButton' style='margin-left:auto' title='Copy to clipboard a URL for this event'>Shareable link</span>
                </div>
                ${content}`;

	    infoBox.querySelector('#shareableLink').addEventListener('click', () => this._copyLinkToClipboard());
	    
	    infoBox.scrollTop = 0;
	})();
    }
    

    /**************************************************************************/
    _showPopUp (message, popUpId, duration = 1000)
    {
	const popup = document.getElementById(popUpId);
	popup.textContent = message;
	popup.style.display = "block";
	popup.style.opacity = "1";

	// Fade out after 'duration' milliseconds
	setTimeout(() => {
	    popup.style.opacity = "0";
	    setTimeout(() => {
		popup.style.display = "none";
	    }, 1000); // Wait for fade-out transition to finish
	}, duration);
    }
}

const _JChronologyPresentationHandler = new _ClassJChronologyPresentationHandler();





/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                                Utilities                                 **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
class _ClassJChronologyUtilities
{
    /**************************************************************************/
    static C_Dbg = false;
    static C_nChannels = 4;


    /**************************************************************************/
    /* There are C_nChannels channels which are used to hold durations.  Plus
       it is convenient to treat the timeline as though it were a standard
       channel.  The timeline is therefore channelNo zero, and the others
       start at 1. */
    
    static getChannelLeft (channelNo)
    {
	const lineWidth= this.getDurationLineWidth();
	const durationLineSeparation = this.getDurationLinesHorizontalSeparation();
	const left = 5;
	return left + channelNo * (lineWidth + durationLineSeparation);
    }

    
    /**************************************************************************/
    static getDurationLinesHorizontalSeparation ()
    {
	return parseFloat(_ClassCommon.getVariableSetting('--durationLinesHorizontalSeparation'));
    }

    
    /**************************************************************************/
    static getDurationLineWidth ()
    {
	return parseFloat(_ClassCommon.getVariableSetting('--durationLineWidth'));
    }

    
    static getTimelineHolderWidth ()
    {
	return parseFloat(_ClassCommon.getVariableSetting('--circleMarkerSize'));
    }

    
    /**************************************************************************/
    static getWidthOfDurationLinesDiv ()
    {
	return this.getChannelLeft(this.C_nChannels);
    }

    
    /**************************************************************************/
    static getWidthOfTimelineHolderDiv ()
    {
	return parseFloat(_ClassCommon.getVariableSetting('--circleMarkerSize'));
    }

    
    /**************************************************************************/
    /* The yearDescription field may contain down-arrows, linking it to the
       duration lines.  The link is establised using colours.  Links are marked
       in the incoming data by jChronDurationLinktags - all we need do here is
       convert them to spans. */
    
    static withDurationColours (s)
    {
	return s.replaceAll('jChronDurationLink', 'span');
    }

    
    /**************************************************************************/
    /* Takes the data associated with a chapter pseudo event and returns
       something which makes the individual scriptures clickable. */
    
    static withChapterScriptureLinks (s)
    {
	return '<span class="jframework-linkAsButton" onclick="JEventHandlers.updateScriptureWindow(this)">' + s + '</span>';
    }
}





/*!****************************************************************************/
/******************************************************************************/
/**                                                                          **/
/**                            Important elements                            **/
/**                                                                          **/
/******************************************************************************/
/******************************************************************************/

/******************************************************************************/
/* Things which are possibly going to be required quite frequently.  The idea
   is that I do lazy evaluation here, so I find the relevant elements only
   when they are needed, and then do not need to rescan the DOM if they are
   needed again. */

class _ClassCommon
{
    /**************************************************************************/
    static _arbitraryDateMarker = null;
    static getArbitraryDateMarker () { return _ClassCommon._arbitraryDateMarker; } // The marker used when asked to select a date which does not exist in hte events list.
    static setArbitraryDateMarker (marker) { _ClassCommon._arbitraryDateMarker = marker; }


    /**************************************************************************/
    static _contentContainer = null;
    static getContentContainer () // The div which holds the whole of the lower part of the screen.
    {
	if (null === _ClassCommon._contentContainer)
	    _ClassCommon._contentContainer = document.getElementById('CONTENT');
	return _ClassCommon._contentContainer;
    }


    /**************************************************************************/
    /* The divs into which dates, year descriptions, etc are placed.  In
       theory there is nothing to stop these being reordered, so long as
       jchronologySelectedItemHighlighterHolder remains as the first one,
       and jchronologyYearDescriptions as the last.  Also columns (other than
       the first and last) could theoretically be hidden at run-time, for
       instance to show just one column of dates rather than two. However,
       none of that has been tested. */

    static _verticalDivIds = ['jchronologySelectedItemHighlighterHolder', 'jchronologyOtherDates', 'jchronologyModernDates', 'jchronologyTimelineHolder', 'jchronologyDurationLines', 'jchronologyYearDescriptions'];
    static _verticalDivsAsList = null;
    static _verticalDivsAsObject = null;
    static getVerticalDiv (id) { return this._verticalDivsAsObject[id]; }
    static getVerticalDivs () { return this._verticalDivsAsList.map( x => x.div ) }
    static getVerticalDivIds () { return this._verticalDivIds; }
    static setVerticalDivs (verticalDivs)
    {
	this._verticalDivsAsList = verticalDivs;
	this._verticalDivsAsObject = Object.fromEntries(verticalDivs.map(o => [o.id, o.div]));
    }

    static getVerticalDivHorizontalPosition (selector)
    {
	if (Number.isInteger(selector))
	    selector = this._verticalDivIds[Number(selector)];

	const div = this.getVerticalDiv(selector);
	const parent = div.parentElement;
	const rect = div.getBoundingClientRect()

	return { left: rect.left - parent.getBoundingClientRect().left, width: rect.width };
    }
	

    
    /**************************************************************************/
    static _columnsContainer = null;
    static getColumnsContainer () // The div at the top of the graphics area which gives headers for things only partially visible.
    {
	if (null === _ClassCommon._columnsContainer)
	    _ClassCommon._columnsContainer = document.getElementById('jchronologyColumnsContainer');
	return _ClassCommon._columnsContainer;
    }


    /**************************************************************************/
    static _durationHeaderContainer = null;
    static getDurationHeaderContainer () // The div at the top of the graphics area which gives headers for things only partially visible.
    {
	if (null === _ClassCommon._durationHeaderContainer)
	    _ClassCommon._durationHeaderContainer = document.getElementById('jchronologyDurationHeaders');
	return _ClassCommon._durationHeaderContainer;
    }


    /**************************************************************************/
    static getDurationLinesContainer () // The div which holds the timeline and associated graphics.
    {
	return _ClassCommon.getVerticalDiv('jchronologyDurationLines');
    }


    /**************************************************************************/
    static getVariableSetting (name)
    {
	return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    }

    
    /**************************************************************************/
    static _selectedItemHighlighter = null;
    static setSelectedItemHighlighter (div) { this._selectedItemHighlighter = div; }
    static getSelectedItemHighlighter () { return this._selectedItemHighlighter; }

    
    /**************************************************************************/
    static _verticalGapBetweenConsecutiveDurationLines = null;
    static getVerticalGapBetweenConsecutiveDurationLines ()
    {
	if (null === this._verticalGapBetweenConsecutiveDurationLines)
	    this._verticalGapBetweenConsecutiveDurationLines = _ClassCommon.getVariableSetting('--verticalGapBetweenConsecutiveDurationLines');
	return this._verticalGapBetweenConsecutiveDurationLines
    }


    /**************************************************************************/
    /* The following is seriously unpleasant ...

       I have, in the :root section of the HTML file, some calc values which
       I need to use in the code here.  Unfortunately, calc values in a
       pure definition aren't resolved -- if you access them, you just get
       'calc(12 + 13)' or whatever.  The only way you can resolve them is
       actually to make HTML make use of them -- which means (with the
       numeric values I have here) setting numeric style properties to these
       values.  Once you have done that, you can then pick up the values
       you require from that tag.  In this case, the tag has id
       dummyRootResolver.

       One downside to this is that you have to give the values to things like
       margin-top etc, and it is not at all obvious that in order to pick up
       the value of --myValue, you need to access margin-top for the purpose.
       To ameliorate this slightly, I have added attributes to dummyRootResolver
       which associate the name you want to look up with the name of the
       property which has that value -- eg myValue='margin-top'.

       With all of that, the code here can then get at the values you want
       and can use meaningful names for the purpose.

       There is still one other issue, however.  The values I want here are
       used quite frequently, and I think they may be fairly expensive to
       obtain, so I cache them here.  Except that cached values are no good
       when, say, the user decides to change the font size.

       Fortunately, all of the values here are used in one place, while
       rendering the timeline, so 'all' you need do is make sure you call
       resetRootResolver before you first need to access them. */
    
    /**************************************************************************/
    static _dummyRootResolver = null;
    static _dummyRootResolverMap = null;
    static _initDummyRootResolver ()
    {
	if (null !== this._dummyRootResolver)
	    return;

	this._dummyRootResolver = document.getElementById('dummyRootResolver');
	this._dummyRootResolverMap = new Map();
	for (var attr of this._dummyRootResolver.attributes)
	    if (attr.name != 'id')
		this._dummyRootResolverMap.set(attr.name, getComputedStyle(this._dummyRootResolver)[attr.value]);
    }

    
    /**************************************************************************/
    static _getFromRootResolver (name)
    {
	this._initDummyRootResolver();
	return parseFloat(this._dummyRootResolverMap.get(name.toLowerCase()));
    }

    
    /**************************************************************************/
    static resetRootResolver () { this._dummyRootResolver = null; }

    
    /**************************************************************************/
    static getVerticalSpaceForDatesMinimumToAvoidOverlap () { return this._getFromRootResolver('verticalSpaceForDatesMinimumToAvoidOverlap'); }
    static getVerticalSpacePerYearForAmDates             () { return this._getFromRootResolver('verticalSpacePerYearForAmDates'); }
    static getVerticalSpacePerYearForNonAmDates          () { return this._getFromRootResolver('verticalSpacePerYearForNonAmDates'); }
}
